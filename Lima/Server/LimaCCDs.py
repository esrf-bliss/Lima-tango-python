#!/usr/bin/env python
############################################################################
# This file is part of LImA, a Library for Image Acquisition
#
# Copyright (C) : 2009-2022
# European Synchrotron Radiation Facility
# CS40220 38043 Grenoble Cedex 9
# FRANCE
# Contact: lima@esrf.fr
#
# This is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>.
############################################################################
# =============================================================================
#
# file :        LimaCCDs.py
#
# description : Python source for the LimaCCDs and its commands.
#               The class is derived from Device. It represents the
#               CORBA servant object which will be accessed from the
#               network. All commands which can be executed on the
#               LimaCCDs are implemented in this file.
#
# project :    TANGO Device Server
#
# copyleft :    European Synchrotron Radiation Facility
#        BP 220, Grenoble 38043
#        FRANCE
#
# =============================================================================
#        This file is generated by seb
#
#      (c) - BLISS - ESRF
# =============================================================================
#

import sys, os, glob
import PyTango
import weakref
import itertools
import functools
import numpy
import struct
import time
import re
import six

# Before loading Lima.Core, must find out the version the plug-in
# was compiled with - horrible hack ...
LimaCameraType = None
# if 'linux' in sys.platform:
#    from EnvHelper import setup_lima_env
#    LimaCameraType = setup_lima_env(sys.argv)

from .EnvHelper import get_sub_devices
from .EnvHelper import get_lima_camera_type, get_lima_device_name
from .EnvHelper import get_camera_module, get_plugin_module
from .AttrHelper import get_attr_4u
from Lima.Server.AttrHelper import getDictKey, getDictValue
from Lima import Core

from Lima.Server import plugins
from Lima.Server import camera

if len(sys.argv) > 1:
    instance_name = sys.argv[1]
else:
    instance_name = ""

from Lima.Server import EdfFile

TacoSpecificDict = {}
TacoSpecificName = []

VerboseLevel2TypeFlags = {
    0: ["Fatal"],
    1: ["Error"],
    2: ["Warning"],
    3: ["Trace"],
    4: ["Funct", "Param", "Return"],
}

SystemFeatures = {}


def SystemHasFeature(feature):
    global SystemFeatures

    if feature in SystemFeatures:
        return SystemFeatures[feature]

    ok = True
    for i, name in enumerate(feature.split(".")):
        try:
            if i == 0:
                obj = globals()[name]
            else:
                obj = getattr(obj, name)
        except AttributeError:
            ok = False
            break

    SystemFeatures[feature] = ok
    return ok


def RequiresSystemFeature(feature):
    def method_decorator(f):
        def unsupported_method(*args, **kws):
            if SystemHasFeature(feature):
                return f(*args, **kws)
            re_obj = re.compile("(?P<op>(read|write))_(?P<attr>.+)")
            m = re_obj.match(f.__name__)
            if m:
                head = "attr. %s [%s]" % (m.group("attr"), m.group("op"))
            else:
                head = "method %s" % f.__name__
            op = re.compile
            msg = (
                "Error: %s cannot be called because %s is not supported "
                "in this (detector-required) version of LIMA" % (head, feature)
            )
            raise RuntimeError(msg)

        return unsupported_method

    return method_decorator


class LimaCCDs(PyTango.LatestDeviceImpl):

    Core.DEB_CLASS(Core.DebModApplication, "LimaCCDs")

    _ImageOpModes = {
        "HardOnly": Core.CtImage.HardOnly,
        "SoftOnly": Core.CtImage.SoftOnly,
        "HardAndSoft": Core.CtImage.HardAndSoft,
    }

    _debugModuleList = [
        "None",
        "Common",
        "Hardware",
        "HardwareSerial",
        "Control",
        "Espia",
        "EspiaSerial",
        "Focla",
        "Camera",
        "CameraCom",
        "Test",
        "Application",
    ]

    _debugTypeList = [
        "Fatal",
        "Error",
        "Warning",
        "Trace",
        "Funct",
        "Param",
        "Return",
        "Always",
    ]

    ImageType2NbBytes = {
        Core.Bpp8: (1, 0),
        Core.Bpp8S: (1, 1),
        Core.Bpp10: (2, 0),
        Core.Bpp10S: (2, 1),
        Core.Bpp12: (2, 0),
        Core.Bpp12S: (2, 1),
        Core.Bpp14: (2, 0),
        Core.Bpp14S: (2, 1),
        Core.Bpp16: (2, 0),
        Core.Bpp16S: (2, 1),
        Core.Bpp32: (4, 0),
        Core.Bpp32S: (4, 1),
    }

    ImageType2String = {
        Core.Bpp8: "Bpp8",
        Core.Bpp8S: "Bpp8S",
        Core.Bpp10: "Bpp10",
        Core.Bpp10S: "Bpp10S",
        Core.Bpp12: "Bpp12",
        Core.Bpp12S: "Bpp12S",
        Core.Bpp14: "Bpp14",
        Core.Bpp14S: "Bpp14S",
        Core.Bpp16: "Bpp16",
        Core.Bpp16S: "Bpp16S",
        Core.Bpp32: "Bpp32",
        Core.Bpp32S: "Bpp32S",
    }
    
    String2ImageType = { v: k for k, v in ImageType2String.items() }

    # DATA_ARRAY DevEncoded
    # enum DataArrayCategory {
    # ScalarStack = 0;
    # Spectrum;
    # Image;
    # SpectrumStack;
    # ImageStack;
    # };

    class DataArrayCategory:
        ScalarStack, Spectrum, Image, SpectrumStack, ImageStack = range(5)

    # enum DataArrayType{
    # DARRAY_UINT8 = 0;
    # DARRAY_UINT16;
    # DARRAY_UINT32;
    # DARRAY_UINT64;
    # DARRAY_INT8;
    # DARRAY_INT16;
    # DARRAY_INT32;
    # DARRAY_INT64;
    # DARRAY_FLOAT32;
    # DARRAY_FLOAT64;
    # };

    ImageType2DataArrayType = {
        Core.Bpp8: 0,
        Core.Bpp10: 1,
        Core.Bpp12: 1,
        Core.Bpp14: 1,
        Core.Bpp16: 1,
        Core.Bpp32: 2,
        Core.Bpp8S: 4,
        Core.Bpp10S: 5,
        Core.Bpp12S: 5,
        Core.Bpp14S: 5,
        Core.Bpp16S: 5,
        Core.Bpp32S: 6,
    }

    # The DATA_ARRAY definition v4
    # struct {
    # unsigned int Magic= 0x44544159;
    # unsigned short Version;
    # unsigned  short HeaderLength;
    # DataArrayCategory Category;
    # DataArrayType DataType;
    # unsigned short DataEndianness;
    # unsigned short NbDim;
    # unsigned short Dim[6]
    # unsigned int DimStepBytes[6]
    # unsigned long ImageNumber;
    # unsigned long AcqTag;
    # unsigned int pading[2];
    # } DataArrayHeaderStruct;

    DataArrayVersion = 4
    DataArrayPackStr = "<IHHIIHHHHHHHHIIIIIIQQII"
    DataArrayMagic = struct.unpack(">I", b"DTAY")[0]  # 0x44544159
    DataArrayMinHeaderLen = 64  # v1/2/3 backward compat.
    DataArrayMaxNbDim = 6

    def DataArrayUser(klass, DataArrayCategory=DataArrayCategory):
        klass.DataArrayCategory = DataArrayCategory
        return klass

    AcqTagNone = 0xffffffff

    # INIT events on video_last_image
    class VideoImageCallback(Core.CtVideo.ImageCallback):
        def __init__(self, device):
            Core.CtVideo.ImageCallback.__init__(self)
            self.__device = weakref.ref(device)
            self.__video_last_image_timestamp = 0

        def newImage(self, image):
            ts = time.time()
            device = self.__device()
            dt = ts - self.__video_last_image_timestamp
            if device.MaxVideoFPS <= 0 or dt >= 1.0 / device.MaxVideoFPS:
                self.__video_last_image_timestamp = ts
                device.push_change_event(
                    "video_last_image_counter", image.frameNumber()
                )
                device.push_change_event(
                    "video_last_image", "VIDEO_IMAGE", _video_image_2_struct(image)
                )

    @DataArrayUser
    class ImageStatusCallback(Core.CtControl.ImageStatusCallback):

        DefaultMaxEventRate = 25

        def __init__(self, device, control, events=False):
            Core.CtControl.ImageStatusCallback.__init__(self)
            self.__events = events
            self.__device = weakref.ref(device)
            self.__control = weakref.ref(control)
            self.__last_base_image_ready = None
            self.__last_counter_ready = None
            self.__last_image_acquired = None
            self.__last_image_ready = None
            self.__last_image_saved = None
            self.__image_events_push_data = False
            self.__last_event_time = 0
            self.__image_events_max_rate = self.DefaultMaxEventRate
            self.__last_acq_status = None

        def imageStatusChanged(self, image_status):
            tn = time.time()
            # time before which no event will be sent.
            # Event will be sent regardless of time if (or):
            # - last_acquired < 0
            # - acq_status changed to ready, so that clients
            #   dont miss the last image
            te = self.__last_event_time + 1.0 / self.__image_events_max_rate

            status = self.__control().getStatus().AcquisitionStatus
            stat_change = status != self.__last_acq_status
            # if the TangoEvent property is not set, the counters/image
            # are not pushed
            # if the property is set, we only send if
            # WARNING : this needs to be reworked as this means
            # that the last events before the acquisition finishes
            # can be lost
            last_image_acquired = image_status.LastImageAcquired
            if self.__events and (tn >= te or last_image_acquired < 0 or stat_change):
                last_base_image_ready = image_status.LastBaseImageReady
                last_image_ready = image_status.LastImageReady
                last_counter_ready = image_status.LastCounterReady
                last_image_ready = image_status.LastImageReady
                last_image_saved = image_status.LastImageSaved

                device = self.__device()
                if self.__last_base_image_ready != last_base_image_ready:
                    device.push_change_event(
                        "last_base_image_ready", last_base_image_ready
                    )
                    self.__last_base_image_ready = last_base_image_ready
                if self.__last_counter_ready != last_counter_ready:
                    device.push_change_event("last_counter_ready", last_counter_ready)
                if self.__last_image_acquired != last_image_acquired:
                    device.push_change_event("last_image_acquired", last_image_acquired)
                    self.__last_image_acquired = last_image_acquired
                if self.__last_image_ready != last_image_ready:
                    device.push_change_event("last_image_ready", last_image_ready)
                    self.__last_image_ready = last_image_ready
                    if (last_image_ready >= 0) and self.__image_events_push_data:
                        control = self.__control()
                        image = control.ReadImage(last_image_ready)
                        category = self.DataArrayCategory.Image
                        data = device._image_2_data_array(image, category)
                        device.push_change_event("last_image", "DATA_ARRAY", data)
                if self.__last_image_saved != last_image_saved:
                    device.push_change_event("last_image_saved", last_image_saved)
                    self.__last_image_saved = last_image_saved

                self.__last_event_time = time.time()

            # pushing the status if:
            # - it has changed since the last callback call
            # - the counters are < 0 (e.g : prepare acq)
            # - the previous known status was None, which can happen
            #   when:
            #     * first frame after a server reset
            #     * first frame after a prepareacq. This is done
            #       so because when only one frame is acquired, the status
            #       is "AcqRead" after the prepare, and already back to
            #       "AcqReady" when the first and only frame comes in,
            #       so we never see the change of status.
            if stat_change or image_status.LastImageAcquired < 0:
                if image_status.LastImageAcquired < 0:
                    self.__last_acq_status = None
                else:
                    self.__last_acq_status = status
                self.__device().push_change_event(
                    "acq_status", _acqstate2string(status)
                )

        def getImageEventsPushData(self):
            return self.__image_events_push_data

        def setImageEventsPushData(self, events):
            self.__image_events_push_data = events

        def getImageEventsMaxRate(self):
            return self.__image_events_max_rate

        def setImageEventsMaxRate(self, max_rate):
            self.__image_events_max_rate = max_rate

    # ------------------------------------------------------------------
    #    Device constructor
    # ------------------------------------------------------------------
    def __init__(self, *args):
        PyTango.LatestDeviceImpl.__init__(self, *args)
        self.__className2deviceName = {}
        self.init_device()
        self.__lima_control = None

        self.__key_header_delimiter = "="
        self.__entry_header_delimiter = "\n"
        self.__image_number_header_delimiter = ";"
        self.__readImage_frame_number = 0
        self.__configInit = False

    # ------------------------------------------------------------------
    #    Device destructor
    # ------------------------------------------------------------------
    @Core.DEB_MEMBER_FUNCT
    def delete_device(self):
        try:
            m = get_camera_module(self.LimaCameraType)
        except ImportError:
            pass
        else:
            try:
                m.close_interface()
            except AttributeError:
                pass

    # ------------------------------------------------------------------
    #    Device initialization
    # ------------------------------------------------------------------
    @Core.DEB_MEMBER_FUNCT
    def init_device(self):
        self.set_state(PyTango.DevState.ON)
        self.get_device_properties(self.get_device_class())
        self.__className2deviceName = get_sub_devices()
        dataBase = PyTango.Database()

        TacoSpecificName.append(self.LimaCameraType)

        self.__control = _get_control()

        # For performance settings Pool thread (default 2) and Writing tasks (default 1)
        nb_thread = int(self.NbProcessingThread)
        Core.Processlib.PoolThreadMgr.get().setNumberOfThread(nb_thread)

        max_concurrent_writing_task = int(self.SavingMaxConcurrentWritingTask)
        if SystemHasFeature("Core.CtSaving.setMaxConcurrentWritingTask"):
            saving = self.__control.saving()
            saving.setMaxConcurrentWritingTask(max_concurrent_writing_task)

        interface = self.__control.hwInterface()
        self.__detinfo = interface.getHwCtrlObj(Core.HwCap.DetInfo)

        self.__accThresholdCallback = None

        accThresholdCallbackModule = self.AccThresholdCallbackModule
        if not accThresholdCallbackModule:
            # if NO property accThresholdCallbackModule has been set the member var. is set to []
            pass
        else:
            try:
                m = get_plugin_module(accThresholdCallbackModule)
            except ImportError:
                deb.Error("Couldn't import plugins.%s" % accThresholdCallbackModule)
            else:
                try:
                    func = getattr(m, "get_acc_threshold_callback")
                    self.__accThresholdCallback = func()
                    acc = self.__control.accumulation()
                    acc.registerThresholdCallback(self.__accThresholdCallback)
                except AttributeError:
                    deb.Error(
                        "Accumulation threshold plugins module don't have get_acc_threshold_callback function"
                    )

        # ImageType Bpp32F (Float 32)
        if SystemHasFeature("Core.Bpp32F"):
            self.ImageType2NbBytes[Core.Bpp32F] = (4, 1)
            self.ImageType2String[Core.Bpp32F] = "Bpp32F"
            self.ImageType2DataArrayType[Core.Bpp32F] = 8

        # ImageType Bpp1 to Bpp24
        if SystemHasFeature("Core.Bpp1"):
            for Bpp_type, Bpp_def, Bpp_name, Bpp_size in [
                (Core.Bpp1, (1, 0), "Bpp1", 0),
                (Core.Bpp6, (1, 0), "Bpp6", 0),
                (Core.Bpp12, (2, 0), "Bpp12", 1),
                (Core.Bpp24, (4, 0), "Bpp24", 2),
            ]:
                self.ImageType2NbBytes[Bpp_type] = Bpp_def
                self.ImageType2String[Bpp_type] = Bpp_name
                self.ImageType2DataArrayType[Bpp_type] = Bpp_size

        self.__Name2SubClass = {"acc_time_mode": self.__control.acquisition}

        # Tango Enum to Lima Enum
        self.__Prefix2SubClass = {
            "acc": self.__control.accumulation,
            "acq": self.__control.acquisition,
            "shutter": self.__control.shutter,
            "saving": self.__control.saving,
            "image": self.__control.image,
            "video": self.__control.video,
            "buffer": self.__control.buffer,
        }

        self.__Attribute2FunctionBase = {
            "acq_trigger_mode": "TriggerMode",
            "saving_managed_mode": "ManagedMode",
            "shutter_mode": "Mode",
            "image_rotation": "Rotation",
            "video_mode": "Mode",
            "buffer_max_number": "MaxNumber",
            "acc_mode": "Mode",
            "acc_filter": "Filter",
            "acc_operation": "Operation",
            "acc_threshold_before": "ThresholdBefore",
            "acc_offset_before": "OffsetBefore",
            "acc_hw_nb_buffers": "HwNbBuffers",
        }

        self.__ShutterMode = {
            "MANUAL": Core.ShutterManual,
            "AUTO_FRAME": Core.ShutterAutoFrame,
            "AUTO_SEQUENCE": Core.ShutterAutoSequence,
        }

        self.__AcqMode = {
            "SINGLE": Core.Single,
            "CONCATENATION": Core.Concatenation,
            "ACCUMULATION": Core.Accumulation,
        }

        if SystemHasFeature("Core.CtAcquisition.Live"):
            self.__AccTimeMode = {
                "LIVE": Core.CtAcquisition.Live,
                "REAL": Core.CtAcquisition.Real,
            }
        else:  # Core too Old
            self.__AccTimeMode = {}

        self.__SavingManagedMode = {
            "SOFTWARE": Core.CtSaving.Software,
            "HARDWARE": Core.CtSaving.Hardware,
        }

        # default saving stream
        self.__SavingStream = 0

        saving = self.__control.saving()
        self.__SavingFormat = saving.getFormatListAsString()

        self.__SavingMode = {
            "MANUAL": Core.CtSaving.Manual,
            "AUTO_FRAME": Core.CtSaving.AutoFrame,
            "AUTO_HEADER": Core.CtSaving.AutoHeader,
        }

        self.__SavingOverwritePolicy = {
            "ABORT": Core.CtSaving.Abort,
            "OVERWRITE": Core.CtSaving.Overwrite,
            "APPEND": Core.CtSaving.Append,
        }

        if SystemHasFeature("Core.CtSaving.MultiSet"):
            self.__SavingOverwritePolicy["MULTISET"] = Core.CtSaving.MultiSet

        self.__AcqTriggerMode = {
            "INTERNAL_TRIGGER": Core.IntTrig,
            "EXTERNAL_TRIGGER": Core.ExtTrigSingle,
            "EXTERNAL_TRIGGER_MULTI": Core.ExtTrigMult,
            "EXTERNAL_GATE": Core.ExtGate,
            "EXTERNAL_START_STOP": Core.ExtStartStop,
        }

        if SystemHasFeature("Core.IntTrigMult"):
            self.__AcqTriggerMode["INTERNAL_TRIGGER_MULTI"] = Core.IntTrigMult

        if SystemHasFeature("Core.ExtTrigReadout"):
            self.__AcqTriggerMode["EXTERNAL_TRIGGER_READOUT"] = Core.ExtTrigReadout

        if SystemHasFeature("Core.Rotation_0"):
            self.__ImageRotation = {
                "NONE": Core.Rotation_0,
                "90": Core.Rotation_90,
                "180": Core.Rotation_180,
                "270": Core.Rotation_270,
            }

        if SystemHasFeature("Core.CtAccumulation.Parameters.STANDARD"):
            self.__AccMode = {
                "STANDARD": Core.CtAccumulation.Parameters.STANDARD,
                "THRESHOLD_BEFORE": Core.CtAccumulation.Parameters.THRESHOLD_BEFORE,
                "OFFSET_THEN_THRESHOLD_BEFORE": Core.CtAccumulation.Parameters.OFFSET_THEN_THRESHOLD_BEFORE,
            }

        if SystemHasFeature("Core.CtAccumulation.FILTER_NONE"):
            self.__AccFilter = {
                "FILTER_NONE": Core.CtAccumulation.FILTER_NONE,
                "FILTER_THRESHOLD_MIN": Core.CtAccumulation.FILTER_THRESHOLD_MIN,
                "FILTER_OFFSET_THEN_THRESHOLD_MIN": Core.CtAccumulation.FILTER_OFFSET_THEN_THRESHOLD_MIN,
            }

        if SystemHasFeature("Core.CtAccumulation.ACC_SUM"):
            self.__AccOperation = {
                "ACC_SUM": Core.CtAccumulation.ACC_SUM,
                "ACC_MEAN": Core.CtAccumulation.ACC_MEAN,
                "ACC_MEDIAN": Core.CtAccumulation.ACC_MEDIAN,
            }

        try:
            self.__VideoMode = {
                "Y8": Core.Y8,
                "Y16": Core.Y16,
                "Y32": Core.Y32,
                "Y64": Core.Y64,
                "RGB555": Core.RGB555,
                "RGB565": Core.RGB565,
                "RGB24": Core.RGB24,
                "RGB32": Core.RGB32,
                "BGR24": Core.BGR24,
                "BGR32": Core.BGR32,
                "BAYER_RG8": Core.BAYER_RG8,
                "BAYER_RG16": Core.BAYER_RG16,
                "I420": Core.I420,
                "YUV411": Core.YUV411,
                "YUV422": Core.YUV422,
                "YUV444": Core.YUV444,
            }
        except AttributeError:
            import traceback

            traceback.print_exc()

        if SystemHasFeature("Core.BAYER_BG8"):
            self.__VideoMode["BAYER_BG8"] = Core.BAYER_BG8
            self.__VideoMode["BAYER_BG16"] = Core.BAYER_BG16

        # new formats added in core 1.7
        if SystemHasFeature("Core.YUV411PACKED"):
            self.__VideoMode["YUV411PACKED"] = Core.YUV411PACKED
            self.__VideoMode["YUV422PACKED"] = Core.YUV422PACKED
            self.__VideoMode["YUV444PACKED"] = Core.YUV444PACKED

        self.__VideoSource = {}
        if SystemHasFeature("Core.CtVideo.BASE_IMAGE"):
            self.__VideoSource = {
                "BASE_IMAGE": Core.CtVideo.BASE_IMAGE,
                "LAST_IMAGE": Core.CtVideo.LAST_IMAGE,
            }

        if SystemHasFeature("Core.BufferHelper.Parameters"):
            self.__BufferHelperEnums = {
                "durationPolicy": {
                    "EPHEMERAL": Core.BufferHelper.Parameters.Ephemeral,
                    "PERSISTENT": Core.BufferHelper.Parameters.Persistent, 
                },
                "sizePolicy": {
                    "AUTOMATIC": Core.BufferHelper.Parameters.Automatic,
                    "FIXED": Core.BufferHelper.Parameters.Fixed, 
                },
            }
            self.__BufferParamData = {
                "buffer": {"attr_split": ["alloc"], "name": "Alloc"},
                "acc": {"attr_split": ["buffer"], "name": "Buffer"},
                "saving": {"attr_split": ["zbuffer"], "name": "ZBuffer"},
            }

        # INIT display shared memory
        try:
            self.__shared_memory_names = ["LimaCCds", instance_name]
            shared_memory = self.__control.display()
            shared_memory.setNames(*self.__shared_memory_names)
        except AttributeError:
            pass
        # INIT events on attributes
        attr_list = self.get_device_attr()
        for attr_name in [
            "last_image",
            "last_base_image_ready",
            "last_counter_ready",
            "last_image_acquired",
            "last_image_ready",
            "last_image_saved",
            "video_last_image",
            "video_last_image_counter",
            "acq_status",
        ]:
            attr = attr_list.get_attr_by_name(attr_name)
            attr.set_change_event(True, False)

        if self.TangoEvent:
            self.__video_image_cbk = self.VideoImageCallback(self)
            self.__control.video().registerImageCallback(self.__video_image_cbk)

        # INIT events on last_image_ready
        self.__image_status_cbk = self.ImageStatusCallback(
            self, self.__control, events=self.TangoEvent
        )
        self.__control.registerImageStatusCallback(self.__image_status_cbk)

        # Setup a user-defined detector name if it exists
        if self.UserInstrumentName:
            if SystemHasFeature("Core.HwDetInfoCtrlObj.setInstrumentName"):
                self.__detinfo.setInstrumentName(self.UserInstrumentName)
            else:
                deb.Warning("UserInstrumentName not supported in this version")

        # Setup a user-defined detector name if it exists
        if self.UserDetectorName:
            if SystemHasFeature("Core.HwDetInfoCtrlObj.setUserDetectorName"):
                self.__detinfo.setUserDetectorName(self.UserDetectorName)
            else:
                deb.Warning("UserDetectorName not supported in this version")

        # Setup the max memory usage (%)
        if self.BufferMaxMemory:
            buffer = self.__control.buffer()
            max_mem = int(self.BufferMaxMemory)
            if SystemHasFeature("Core.BufferHelper.Parameters"):
                params = buffer.getAllocParameters()
                params.reqMemSizePercent = max_mem
                buffer.setAllocParameters(params)
            else:
                buffer.setMaxMemory(max_mem)

        unsupported_feature = "Core.Never.Unsupported.Feature"
        if SystemHasFeature(unsupported_feature):
            deb.Error("System reports having %s" % unsupported_feature)

        if self.ImageOpMode:
            mode = self._ImageOpModes.get(self.ImageOpMode)
            if mode:
                image = self.__control.image()
                image.setMode(mode)
            else:
                deb.Error(
                    "ImageOpMode='%s' is not allowed. Property ignored."
                    % self.ImageOpMode
                )

        # Setup the BufferHelper Parameters
        if SystemHasFeature("Core.BufferHelper.Parameters"):
            self.apply_buffer_param_properties()

        for feature in SystemFeatures:
            is_not = (SystemHasFeature(feature) and "is") or "is not"
            deb.Trace("Feature %s %s present" % (feature, is_not))

        # Add shutter capability related attributes if supported
        if self.__control.shutter().hasCapability():
            self.add_attribute(
                PyTango.Attr(
                    "shutter_close_time", PyTango.DevDouble, PyTango.READ_WRITE
                ),
                self.read_shutter_close_time,
                self.write_shutter_close_time,
            )
            self.add_attribute(
                PyTango.Attr(
                    "shutter_manual_state", PyTango.DevString, PyTango.READ_WRITE
                ),
                self.read_shutter_manual_state,
                self.write_shutter_manual_state,
            )
            self.add_attribute(
                PyTango.Attr("shutter_mode", PyTango.DevString, PyTango.READ_WRITE),
                self.read_shutter_mode,
                self.write_shutter_mode,
            )
            self.add_attribute(
                PyTango.Attr(
                    "shutter_open_time", PyTango.DevDouble, PyTango.READ_WRITE
                ),
                self.read_shutter_open_time,
                self.write_shutter_open_time,
            )

        # Acquisition number
        self.acq_tag = self.AcqTagNone
        self.last_acq_tag = self.AcqTagNone

    @Core.DEB_MEMBER_FUNCT
    def apply_buffer_param_properties(self):
        for grp, attr_data in self.__BufferParamData.items():
            attr_name_prefix = attr_data["name"]
            prop_name = f"{grp.title()}{attr_name_prefix}Parameters"
            prop_val = getattr(self, prop_name)
            deb.Trace("%s [prop]: '%s'" % (prop_name, prop_val))
            try:
                obj = self.__Prefix2SubClass[grp]()
                get_set_names = [f"{op}{attr_name_prefix}Parameters"
                                 for op in ["get", "set"]]
                getter, setter = [getattr(obj, n) for n in get_set_names]
                if prop_val:
                    params = Core.BufferHelper.Parameters.fromString(prop_val)
                else:
                    params = getter()
                deb.Always("%s [params]: %s" % (prop_name, params))
                setter(params)
            except Exception as e:
                deb.Error("Error setting %s parameters: %s" % (name_prefix, e))

    def __getattr__(self, name):
        if name.startswith("is_") and name.endswith("_allowed"):
            split_name = name.split("_")[1:-1]
            attr_name = "".join([x.title() for x in split_name])
            dict_name = "_" + self.__class__.__name__ + "__" + attr_name
            d = getattr(self, dict_name, None)
            func = _allowed
            if d is not None:
                if not d:
                    func = _not_allowed
            self.__dict__[name] = func
            return func
        else:
            split_name = name.split("_")
            action = split_name.pop(0)
            subClass = self.__Name2SubClass.get("_".join(split_name), None)
            if subClass is None:
                subClass = self.__Prefix2SubClass.get(split_name[0], None)
            if subClass:
                obj = subClass()
                if SystemHasFeature("Core.BufferHelper.Parameters"):
                    buffer_attr = self.get_buffer_param_attr(action, split_name,
                                                             obj)
                    if buffer_attr:
                        return buffer_attr
                return get_attr_4u(self, name, obj)

        raise AttributeError("LimaCCDs has no attribute %s" % name)

    @Core.DEB_MEMBER_FUNCT
    def get_buffer_param_attr(self, action, split_name, obj):
        deb.Param("action=%s, split_name=%s, obj=%s" % (action, split_name, obj))
        for grp, attr_data in self.__BufferParamData.items():
            split_grp = [grp] + attr_data["attr_split"]
            attr_name_prefix = attr_data["name"]
            nb_grp_tokens = len(split_grp)
            if list(split_grp) != split_name[:nb_grp_tokens]:
                continue
            get_set_names = [f"{op}{attr_name_prefix}Parameters"
                             for op in ["get", "set"]]
            if not all([hasattr(obj, n) for n in get_set_names]):
                continue
            method = getattr(self, f"{action}BufferParam")
            param_tokens = split_name[nb_grp_tokens:]
            param = "".join([n.title() if i else n
                             for i, n in enumerate(param_tokens)])
            getter, setter = [getattr(obj, n) for n in get_set_names]
            return functools.partial(method, param=param,
                                     getter=getter, setter=setter)
        return None

    def gc(self):
        import gc

        gc.collect()

    @Core.DEB_MEMBER_FUNCT
    def apply_config(self):
        """
        Apply configuration. Identification of config to apply is found
        in DS properties "ConfigurationDefaultName" and
        "ConfigurationFilePath".
        Apply by default "default" config.
        """
        if not self.__configInit:
            self.__configInit = True
            # Configuration mgt
            config_file_path = self.ConfigurationFilePath
            config_default_name = self.ConfigurationDefaultName

            deb.Always(
                "Applied config : %s : %s " % (config_file_path, config_default_name)
            )
            self.__configDefaultActiveFlag = False
            if SystemHasFeature("Core.CtConfig"):
                config = self.__control.config()
                config.setFilename(config_file_path)
                if os.access(config_file_path, os.R_OK):
                    try:
                        config.load()
                        if config_default_name in config.getAlias():
                            config.apply(config_default_name)
                            self.__configDefaultActiveFlag = True
                    except Core.Exception:
                        pass

    # ==================================================================
    #
    #    LimaCCDs read/write attribute methods
    #
    # ==================================================================

    ## @brief Read the Lima Type
    #
    @RequiresSystemFeature("Core.CtControl.getVersion")
    @Core.DEB_MEMBER_FUNCT
    def read_lima_version(self, attr):
        value = self.__control.getVersion()
        attr.set_value(value)

    @Core.DEB_MEMBER_FUNCT
    def read_lima_type(self, attr):
        value = self.LimaCameraType
        attr.set_value(value)

    ## @brief Read the Camera Type
    #
    @Core.DEB_MEMBER_FUNCT
    def read_camera_type(self, attr):
        value = self.__detinfo.getDetectorType()
        attr.set_value(value)

    ## @brief Read the Camera Model
    #
    @Core.DEB_MEMBER_FUNCT
    def read_camera_model(self, attr):
        value = self.__detinfo.getDetectorModel()
        attr.set_value(value)

    ## @brief Read the User-defined Camera name
    #
    @RequiresSystemFeature("Core.HwDetInfoCtrlObj.getUserDetectorName")
    @Core.DEB_MEMBER_FUNCT
    def read_user_detector_name(self, attr):
        value = self.__detinfo.getUserDetectorName()
        attr.set_value(value)

    ## @brief Write the User-defined Camera name
    #
    @RequiresSystemFeature("Core.HwDetInfoCtrlObj.setUserDetectorName")
    @Core.DEB_MEMBER_FUNCT
    def write_user_detector_name(self, attr):
        data = attr.get_write_value()
        self.__detinfo.setUserDetectorName(data)

    ## @brief Read the user instrument name
    #
    @RequiresSystemFeature("Core.HwDetInfoCtrlObj.getInstrumentName")
    @Core.DEB_MEMBER_FUNCT
    def read_user_instrument_name(self, attr):
        value = self.__detinfo.getInstrumentName()
        attr.set_value(value)

    ## @brief Write the user instrument name
    #
    @RequiresSystemFeature("Core.HwDetInfoCtrlObj.setInstrumentName")
    @Core.DEB_MEMBER_FUNCT
    def write_user_instrument_name(self, attr):
        data = attr.get_write_value()
        self.__detinfo.setInstrumentName(data)

    ## @brief Read the Camera pixelsize
    #
    @Core.DEB_MEMBER_FUNCT
    def read_camera_pixelsize(self, attr):
        value = self.__detinfo.getPixelSize()
        attr.set_value(value)

    ## @brief get the status of the acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acq_status(self, attr):
        status = self.__control.getStatus()
        attr.set_value(_acqstate2string(status.AcquisitionStatus))

    ## @brief get the errir message when acq_status is in Fault stat
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acq_status_fault_error(self, attr):
        status = self.__control.getStatus()
        state2string = {
            Core.CtControl.NoError: "No error",
            Core.CtControl.SaveUnknownError: "Saving: unknown error",
            Core.CtControl.SaveOpenError: "Saving: file open error",
            Core.CtControl.SaveCloseError: "Saving: file close error",
            Core.CtControl.SaveAccessError: "Saving: access error",
            Core.CtControl.SaveOverwriteError: "Saving: overwrite error",
            Core.CtControl.SaveDiskFull: "Saving: disk full",
            Core.CtControl.SaveOverun: "Saving: overun",
            Core.CtControl.ProcessingOverun: "Processing: overun",
            Core.CtControl.CameraError: "Camera: error",
        }
        attr.set_value(state2string.get(status.Error, "?"))

    ## @brief get the acquisition tag
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acq_tag(self, attr):
        acq_tag = self.acq_tag
        deb.Return("acq_tag=%s (0x%08x)" % (acq_tag, acq_tag))
        attr.set_value(acq_tag)

    ## @brief set the acquisition tag
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acq_tag(self, attr):
        acq_tag = attr.get_write_value()
        deb.Param("acq_tag=%s (0x%08x)" % (acq_tag, acq_tag))
        self.acq_tag = acq_tag

    ## @brief read the number of frame for an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acq_nb_frames(self, attr):
        acquisition = self.__control.acquisition()
        nb_frames = acquisition.getAcqNbFrames()
        attr.set_value(nb_frames)

    ## @brief write the number of frame for an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acq_nb_frames(self, attr):
        data = attr.get_write_value()
        acquisition = self.__control.acquisition()
        acquisition.setAcqNbFrames(data)

    ## @brief read the number of frame for an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acq_expo_time(self, attr):
        acquisition = self.__control.acquisition()
        expo_time = acquisition.getAcqExpoTime()
        attr.set_value(expo_time)

    ## @brief write the number of frame for an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acq_expo_time(self, attr):
        data = attr.get_write_value()
        acquisition = self.__control.acquisition()
        acquisition.setAcqExpoTime(data)

    ## @brief Read maximum accumulation exposure time
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_max_expo_time(self, attr):
        acq = self.__control.acquisition()

        value = acq.getAccMaxExpoTime()
        if value is None:
            value = -1

        attr.set_value(value)

    ## @brief Write the accumulation max exposure time
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acc_max_expo_time(self, attr):
        data = attr.get_write_value()
        acq = self.__control.acquisition()
        acq.setAccMaxExpoTime(data)

    ## @brief Read maximum accumulation exposure time
    #
    @Core.DEB_MEMBER_FUNCT
    def read_concat_nb_frames(self, attr):
        acq = self.__control.acquisition()
        value = acq.getConcatNbFrames()
        attr.set_value(value)

    ## @brief Write the accumulation max exposure time
    #
    @Core.DEB_MEMBER_FUNCT
    def write_concat_nb_frames(self, attr):
        data = attr.get_write_value()
        acq = self.__control.acquisition()
        acq.setConcatNbFrames(data)

    ## @brief Read calculated accumulation exposure time
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_expo_time(self, attr):
        acq = self.__control.acquisition()

        value = acq.getAccExpoTime()
        if value is None:
            value = -1

        attr.set_value(value)

    ## @brief Read calculated accumulation number of frames
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_nb_frames(self, attr):
        acq = self.__control.acquisition()
        value = acq.getAccNbFrames()
        if value is None:
            value = -1

        attr.set_value(value)

    ## @brief Read calculated accumulation dead time
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_dead_time(self, attr):
        acq = self.__control.acquisition()
        value = acq.getAccDeadTime()

        attr.set_value(value)

    ## @brief Read calculated accumulation live time
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_live_time(self, attr):
        acq = self.__control.acquisition()
        value = acq.getAccLiveTime()

        attr.set_value(value)

    ## @brief Read if saturated calculation is active
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_saturated_active(self, attr):
        acc = self.__control.accumulation()
        value = acc.getActive()

        attr.set_value(value)

    ## @brief active/unactive calculation of saturated images and counters
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acc_saturated_active(self, attr):
        data = attr.get_write_value()

        acc = self.__control.accumulation()
        acc.setActive(data)

    ## @brief Read saturated threshold
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_saturated_threshold(self, attr):
        acc = self.__control.accumulation()
        value = acc.getPixelThresholdValue()

        attr.set_value(value)

    ## @brief Set saturated threshold
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acc_saturated_threshold(self, attr):
        data = attr.get_write_value()
        acc = self.__control.accumulation()
        acc.setPixelThresholdValue(data)

    ## @brief Read if saturated calculation is active
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_saturated_cblevel(self, attr):
        if self.__accThresholdCallback is not None:
            attr.set_value(self.__accThresholdCallback.m_max)
        else:
            attr.set_value(-1)

    ## @brief active/unactive calculation of saturated images and counters
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acc_saturated_cblevel(self, attr):
        data = attr.get_write_value()
        if self.__accThresholdCallback is not None:
            self.__accThresholdCallback.m_max = data
        else:
            msg = "Accumulation threshold plugins not loaded"
            deb.Error(msg)
            
    ## @brief Read the output image type (after acumulation)
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_out_type(self, attr):
        acc = self.__control.accumulation()
        imageType = acc.getOutputType()
        stringType = self.ImageType2String.get(imageType, "?")
        
        attr.set_value(stringType)

    ## @brief Write the output image type (after acumulation)
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acc_out_type(self, attr):
        stringType = attr.get_write_value()
        imageType = self.String2ImageType.get(stringType)
        if imageType is not None:
            acc = self.__control.accumulation()
            acc.setOutputType(imageType)
        else:
            PyTango.Except.throw_exception(
                "WrongData",
                "Wrong value %s: %s" % ("acc_out_type", stringType),
                "LimaCCD Class",
            )

    ## @brief Read latency time
    #
    @Core.DEB_MEMBER_FUNCT
    def read_latency_time(self, attr):
        acq = self.__control.acquisition()

        value = acq.getLatencyTime()
        if value is None:
            value = -1

        attr.set_value(value)

    ## @brief Write Latency time
    #
    @Core.DEB_MEMBER_FUNCT
    def write_latency_time(self, attr):
        data = attr.get_write_value()
        acq = self.__control.acquisition()

        acq.setLatencyTime(data)

    ## @brief Read the valid latency and exposure valid ranges
    #
    @Core.DEB_MEMBER_FUNCT
    def read_valid_ranges(self, attr):
        interface = self.__control.hwInterface()
        sync = interface.getHwCtrlObj(Core.HwCap.Sync)
        ranges = sync.getValidRanges()
        attr.set_value(
            [
                ranges.min_exp_time,
                ranges.max_exp_time,
                ranges.min_lat_time,
                ranges.max_lat_time,
            ]
        )

    ## @brief Read image Roi
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_roi(self, attr):
        image = self.__control.image()
        roi = image.getRoi()
        point = roi.getTopLeft()
        size = roi.getSize()

        attr.set_value([point.x, point.y, size.getWidth(), size.getHeight()])

    ## @brief Write image Roi
    #
    @Core.DEB_MEMBER_FUNCT
    def write_image_roi(self, attr):
        data = attr.get_write_value()
        image = self.__control.image()
        roi = Core.Roi(*data)
        image.setRoi(roi)

    ## @brief Read image sizes
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_sizes(self, attr):
        image = self.__control.image()
        imageType = image.getImageType()
        dim = image.getImageDim()
        depth, signed = self.ImageType2NbBytes.get(imageType, (0, 0))
        sizes = [signed, depth, dim.getSize().getWidth(), dim.getSize().getHeight()]

        attr.set_value(sizes)

    ## @brief Read max image dimension in width and height pixels
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_max_dim(self, attr):
        size = self.__detinfo.getMaxImageSize()
        dim = [size.getWidth(), size.getHeight()]

        attr.set_value(dim)

    ## @brief Read image type
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_type(self, attr):
        image = self.__control.image()
        imageType = image.getImageType()
        stringType = self.ImageType2String.get(imageType, "?")

        attr.set_value(stringType)

    ## @brief Read image width
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_width(self, attr):
        image = self.__control.image()
        dim = image.getImageDim()

        attr.set_value(dim.getSize().getWidth())

    ## @brief Read image height
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_height(self, attr):
        image = self.__control.image()
        dim = image.getImageDim()

        attr.set_value(dim.getSize().getHeight())

    ## @brief Read image binning
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_bin(self, attr):
        image = self.__control.image()
        binValues = image.getBin()

        attr.set_value([binValues.getX(), binValues.getY()], 2)

    ## @brief Write image binning
    #
    @Core.DEB_MEMBER_FUNCT
    def write_image_bin(self, attr):
        data = attr.get_write_value()

        image = self.__control.image()
        binValue = Core.Bin(*data)
        image.setBin(binValue)

    ## @brief Read image flip
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_flip(self, attr):
        image = self.__control.image()
        flip = image.getFlip()
        attr.set_value([flip.x, flip.y], 2)

    ## @brief Write image flip
    #
    @Core.DEB_MEMBER_FUNCT
    def write_image_flip(self, attr):
        data = attr.get_write_value()
        flip = Core.Flip(*data)
        image = self.__control.image()
        image.setFlip(flip)

    ## @brief Read common header
    #
    @Core.DEB_MEMBER_FUNCT
    def read_saving_common_header(self, attr):
        saving = self.__control.saving()
        header = saving.getCommonHeader()
        headerArr = [
            "%s%s%s" % (k, self.__key_header_delimiter, v)
            for k, v in six.iteritems(header)
        ]
        attr.set_value(headerArr, len(headerArr))

    ## @brief Write common header
    #
    @Core.DEB_MEMBER_FUNCT
    def write_saving_common_header(self, attr):
        data = attr.get_write_value()
        header = dict([x.split(self.__key_header_delimiter, 1) for x in data])
        saving = self.__control.saving()
        saving.setCommonHeader(header)

    ## @brief Read header delimiter
    #
    @Core.DEB_MEMBER_FUNCT
    def read_saving_header_delimiter(self, attr):
        attr.set_value(
            [
                self.__key_header_delimiter,
                self.__entry_header_delimiter,
                self.__image_number_header_delimiter,
            ],
            3,
        )

    ##@brief Write header delimiter
    #
    def write_saving_header_delimiter(self, attr):
        data = attr.get_write_value()
        self.__key_header_delimiter = data[0]
        self.__entry_header_delimiter = data[1]
        self.__image_number_header_delimiter = data[2]

    def read_saving_index_format(self, attr):
        saving = self.__control.saving()
        params = saving.getParameters()
        attr.set_value(params.indexFormat)

    def write_saving_index_format(self, attr):
        data = attr.get_write_value()
        saving = self.__control.saving()
        params = saving.getParameters()
        params.indexFormat = data
        saving.setParameters(params)

    ## @brief last image
    #
    @Core.DEB_MEMBER_FUNCT
    def read_last_image(self, attr):
        status = self.__control.getStatus()
        last_img_ready = status.ImageCounters.LastImageReady
        image = self.__control.ReadImage(last_img_ready)
        # workaround for PyTango #147
        self._lidata = self._image_2_data_array(image, self.DataArrayCategory.Image)
        attr.set_value("DATA_ARRAY", self._lidata)

    ## @brief last image acquired
    #
    @Core.DEB_MEMBER_FUNCT
    def read_last_image_acquired(self, attr):
        status = self.__control.getStatus()
        img_counters = status.ImageCounters

        value = img_counters.LastImageAcquired
        attr.set_value(value)

    ## @brief last base image acquired
    #
    @Core.DEB_MEMBER_FUNCT
    def read_last_base_image_ready(self, attr):
        status = self.__control.getStatus()
        img_counters = status.ImageCounters

        value = img_counters.LastBaseImageReady
        attr.set_value(value)

    ## @brief Read last image ready
    #
    @Core.DEB_MEMBER_FUNCT
    def read_last_image_ready(self, attr):
        status = self.__control.getStatus()
        img_counters = status.ImageCounters

        value = img_counters.LastImageReady

        attr.set_value(value)

    ## @brief last counter ready
    #
    @Core.DEB_MEMBER_FUNCT
    def read_last_counter_ready(self, attr):
        status = self.__control.getStatus()
        img_counters = status.ImageCounters

        value = img_counters.LastCounterReady

        attr.set_value(value)

    ## @brief Read last image saved
    #
    @Core.DEB_MEMBER_FUNCT
    def read_last_image_saved(self, attr):
        status = self.__control.getStatus()
        img_counters = status.ImageCounters

        value = img_counters.LastImageSaved
        if value is None:
            value = -1

        attr.set_value(value)

    ## @brief get if last_image attr pushes events
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_events_push_data(self, attr):
        image_events = self.__image_status_cbk.getImageEventsPushData()
        attr.set_value(image_events)

    ## @brief set if last_image attr pushes events
    #
    @Core.DEB_MEMBER_FUNCT
    def write_image_events_push_data(self, attr):
        image_events = attr.get_write_value()
        self.__image_status_cbk.setImageEventsPushData(image_events)

    ## @brief get the max event generation rate
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_events_max_rate(self, attr):
        event_rate = self.__image_status_cbk.getImageEventsMaxRate()
        attr.set_value(event_rate)

    ## @brief set the max event generation rate
    #
    @Core.DEB_MEMBER_FUNCT
    def write_image_events_max_rate(self, attr):
        event_rate = attr.get_write_value()
        self.__image_status_cbk.setImageEventsMaxRate(event_rate)

    ## @brief this flag is true just after
    #  the detector readout.
    #
    # This attribute should be use
    #  to test is client can re-trigger an other image
    @Core.DEB_MEMBER_FUNCT
    def read_ready_for_next_image(self, attr):
        interface = self.__control.hwInterface()
        status = interface.getStatus()
        ready = status.det == Core.DetIdle or status.det & Core.DetWaitForTrigger
        attr.set_value(bool(ready))

    ## @brief this flag is true when acquisition is finished
    #
    @Core.DEB_MEMBER_FUNCT
    def read_ready_for_next_acq(self, attr):
        status = self.__control.getStatus()
        attr.set_value(status.AcquisitionStatus == Core.AcqReady)

    ## @brief read write statistic
    #
    # return saving_speed,compression_speed, compression_ratio,incoming_speed
    @Core.DEB_MEMBER_FUNCT
    def read_saving_statistics(self, attr):
        saving = self.__control.saving()
        attr.set_value(saving.getStatisticCounters(), 4)

    ## @brief get the write statistics history size
    #
    @Core.DEB_MEMBER_FUNCT
    def read_saving_statistics_history(self, attr):
        saving = self.__control.saving()
        attr.set_value(saving.getStatisticHistorySize())

    ## @brief set the write statistics history size
    #
    @Core.DEB_MEMBER_FUNCT
    def write_saving_statistics_history(self, attr):
        stat_size = attr.get_write_value()
        saving = self.__control.saving()
        saving.setStatisticHistorySize(stat_size)

    ## @brief get statistics log enabled flag
    #
    @Core.DEB_MEMBER_FUNCT
    def read_saving_statistics_log_enable(self, attr):
        saving = self.__control.saving()
        attr.set_value(saving.getEnableLogStat())

    ## @brief set statistics log enable flag
    #
    @Core.DEB_MEMBER_FUNCT
    def write_saving_statistics_log_enable(self, attr):
        flag = attr.get_write_value()
        saving = self.__control.saving()
        saving.setEnableLogStat(flag)

    ## @brief Write current shutter state if in manual mode
    # True-Open, False-Close
    @Core.DEB_MEMBER_FUNCT
    def write_shutter_manual_state(self, attr):
        state = attr.get_write_value()
        if state not in ["OPEN", "CLOSE", "NO_MANUAL_MODE"]:
            raise Exception("Invalid shutter state")

        shutter = self.__control.shutter()
        if (
            shutter.getModeList().count(Core.ShutterManual)
            and shutter.getMode() == Core.ShutterManual
            and state in ["OPEN", "CLOSE"]
        ):
            shutter.setState(state == "OPEN")
        else:
            raise Exception("Shutter not in manual mode")

    ## @brief Read current shutter state if in manual mode
    # True-Open, False-Close
    @Core.DEB_MEMBER_FUNCT
    def read_shutter_manual_state(self, attr):
        shutter = self.__control.shutter()

        if (
            shutter.getModeList().count(Core.ShutterManual)
            and shutter.getMode() == Core.ShutterManual
        ):
            if shutter.getState():
                state = "OPEN"
            else:
                state = "CLOSED"
        else:
            state = "NO_MANUAL_MODE"

        attr.set_value(state)

    ## @brief Read shutter open time
    # True-Open, False-Close
    @Core.DEB_MEMBER_FUNCT
    def read_shutter_open_time(self, attr):
        shutter = self.__control.shutter()

        value = shutter.getOpenTime()
        if value is None:
            value = -1

        attr.set_value(value)

    ## @brief Write shutter open time
    #
    @Core.DEB_MEMBER_FUNCT
    def write_shutter_open_time(self, attr):
        data = attr.get_write_value()
        shutter = self.__control.shutter()

        shutter.setOpenTime(data)

    ## @brief Read shutter close time
    # in seconds
    @Core.DEB_MEMBER_FUNCT
    def read_shutter_close_time(self, attr):
        shutter = self.__control.shutter()

        value = shutter.getCloseTime()
        if value is None:
            value = -1

        attr.set_value(value)

    ## @brief Write shutter close time
    # in seconds
    @Core.DEB_MEMBER_FUNCT
    def write_shutter_close_time(self, attr):
        data = attr.get_write_value()
        shutter = self.__control.shutter()

        shutter.setCloseTime(data)

    @Core.DEB_MEMBER_FUNCT
    def read_saving_directory(self, attr):
        saving = self.__control.saving()

        attr.set_value(saving.getDirectory(self.__SavingStream))

    @Core.DEB_MEMBER_FUNCT
    def write_saving_directory(self, attr):
        data = attr.get_write_value()
        saving = self.__control.saving()
        saving.setDirectory(data, self.__SavingStream)

    @Core.DEB_MEMBER_FUNCT
    def read_saving_prefix(self, attr):
        saving = self.__control.saving()

        attr.set_value(saving.getPrefix(self.__SavingStream))

    @Core.DEB_MEMBER_FUNCT
    def write_saving_prefix(self, attr):
        data = attr.get_write_value()
        saving = self.__control.saving()
        prefix = data

        directory = saving.getDirectory(self.__SavingStream)
        suffix = saving.getSuffix(self.__SavingStream)
        overwritePolicy = saving.getOverwritePolicy(self.__SavingStream)
        if overwritePolicy == Core.CtSaving.Abort:
            matchFiles = glob.glob(os.path.join(directory, "%s*%s" % (prefix, suffix)))
            lastnumber = _getLastFileNumber(prefix, suffix, matchFiles)
        else:
            lastnumber = -1
        saving.setPrefix(prefix, self.__SavingStream)
        saving.setNextNumber(lastnumber + 1, self.__SavingStream)

    @Core.DEB_MEMBER_FUNCT
    def read_saving_suffix(self, attr):
        saving = self.__control.saving()

        attr.set_value(saving.getSuffix(self.__SavingStream))

    @Core.DEB_MEMBER_FUNCT
    def write_saving_suffix(self, attr):
        data = attr.get_write_value()
        saving = self.__control.saving()

        saving.setSuffix(data, self.__SavingStream)

    @Core.DEB_MEMBER_FUNCT
    def read_saving_next_number(self, attr):
        saving = self.__control.saving()

        attr.set_value(saving.getNextNumber(self.__SavingStream))

    @Core.DEB_MEMBER_FUNCT
    def write_saving_next_number(self, attr):
        data = attr.get_write_value()
        saving = self.__control.saving()

        saving.setNextNumber(data, self.__SavingStream)

    @Core.DEB_MEMBER_FUNCT
    def read_saving_frame_per_file(self, attr):
        saving = self.__control.saving()

        attr.set_value(saving.getFramesPerFile(self.__SavingStream))

    @Core.DEB_MEMBER_FUNCT
    def write_saving_frame_per_file(self, attr):
        data = attr.get_write_value()
        saving = self.__control.saving()

        saving.setFramesPerFile(data, self.__SavingStream)

    @Core.DEB_MEMBER_FUNCT
    def read_saving_every_n_frames(self, attr):
        saving = self.__control.saving()

        attr.set_value(saving.getEveryNFrames(self.__SavingStream))

    @Core.DEB_MEMBER_FUNCT
    def write_saving_every_n_frames(self, attr):
        data = attr.get_write_value()
        saving = self.__control.saving()

        saving.setEveryNFrames(data, self.__SavingStream)

    @Core.DEB_MEMBER_FUNCT
    def read_saving_format(self, attr):
        saving = self.__control.saving()
        attr.set_value(saving.getFormatAsString(self.__SavingStream))

    @Core.DEB_MEMBER_FUNCT
    def write_saving_format(self, attr):
        data = attr.get_write_value()
        value = data.upper()
        saving = self.__control.saving()

        if not value in self.__SavingFormat:
            PyTango.Except.throw_exception(
                "WrongData",
                "Wrong value %s: %s" % ("saving_format", value),
                "LimaCCD Class",
            )
        else:
            saving.setFormatAsString(value, self.__SavingStream)
            saving.setFormatSuffix(self.__SavingStream)

    @Core.DEB_MEMBER_FUNCT
    def read_saving_overwrite_policy(self, attr):
        saving = self.__control.saving()
        attr.set_value(
            getDictKey(
                self.__SavingOverwritePolicy,
                saving.getOverwritePolicy(self.__SavingStream),
            )
        )

    @Core.DEB_MEMBER_FUNCT
    def write_saving_overwrite_policy(self, attr):
        data = attr.get_write_value()
        saving = self.__control.saving()
        value = getDictValue(self.__SavingOverwritePolicy, data.upper())
        if value is None:
            PyTango.Except.throw_exception(
                "WrongData",
                "Wrong value %s: %s" % ("saving_overwrite_policy", data.upper()),
                "LimaCCD Class",
            )
        else:
            saving.setOverwritePolicy(value, self.__SavingStream)

    @Core.DEB_MEMBER_FUNCT
    def read_saving_use_hw_comp(self, attr):
        saving = self.__control.saving()
        attr.set_value(saving.getUseHwComp(self.__SavingStream))

    @Core.DEB_MEMBER_FUNCT
    def write_saving_use_hw_comp(self, attr):
        data = attr.get_write_value()
        saving = self.__control.saving()
        saving.setUseHwComp(data, self.__SavingStream)

    @Core.DEB_MEMBER_FUNCT
    def read_saving_stream_active(self, attr):
        saving = self.__control.saving()
        attr.set_value(saving.getStreamActive(self.__SavingStream))

    @Core.DEB_MEMBER_FUNCT
    def write_saving_stream_active(self, attr):
        data = attr.get_write_value()
        saving = self.__control.saving()
        saving.setStreamActive(self.__SavingStream, data)

    ## @brief get the maximum number of task for concurrent writing (saving)
    #
    @RequiresSystemFeature("Core.CtSaving.setMaxConcurrentWritingTask")
    @Core.DEB_MEMBER_FUNCT
    def read_saving_max_writing_task(self, attr):
        saving = self.__control.saving()
        attr.set_value(saving.getMaxConcurrentWritingTask())

    ## @brief set the maximum number of task for concurrent writing (saving)
    #
    @RequiresSystemFeature("Core.CtSaving.getMaxConcurrentWritingTask")
    @Core.DEB_MEMBER_FUNCT
    def write_saving_max_writing_task(self, attr):
        data = attr.get_write_value()
        saving = self.__control.saving()

        saving.setMaxConcurrentWritingTask(data)

    ##@brief Read possible modules
    #
    def read_debug_modules_possible(self, attr):
        attr.set_value(LimaCCDs._debugModuleList, len(LimaCCDs._debugModuleList))

    ##@brief Read list of module which are in debug
    #
    @Core.DEB_MEMBER_FUNCT
    def read_debug_modules(self, attr):
        NameList = Core.DebParams.getModuleFlagsNameList()
        attr.set_value(NameList, len(NameList))

    ##@brief set debug module list
    #
    @Core.DEB_MEMBER_FUNCT
    def write_debug_modules(self, attr):
        data = attr.get_write_value()
        Core.DebParams.setModuleFlagsNameList(data)

    ##@biref Read possible modules
    #
    def read_debug_types_possible(self, attr):
        attr.set_value(LimaCCDs._debugTypeList, len(LimaCCDs._debugTypeList))

    ##@brief Read list of module which are in debug
    #
    @Core.DEB_MEMBER_FUNCT
    def read_debug_types(self, attr):
        NameList = Core.DebParams.getTypeFlagsNameList()

        if NameList:
            attr.set_value(NameList, len(NameList))
        else:
            attr.set_value([""], 1)

    ##@brief set debug module list
    #
    @Core.DEB_MEMBER_FUNCT
    def write_debug_types(self, attr):
        data = attr.get_write_value()
        Core.DebParams.setTypeFlagsNameList(data)

    def read_video_active(self, attr):
        video = self.__control.video()
        attr.set_value(video.isActive())

    def write_video_active(self, attr):
        video = self.__control.video()
        data = attr.get_write_value()
        video.setActive(data)

    def read_video_live(self, attr):
        video = self.__control.video()
        attr.set_value(video.getLive())

    def write_video_live(self, attr):
        video = self.__control.video()
        data = attr.get_write_value()
        if data:
            video.startLive()
        else:
            video.stopLive()

    def read_video_exposure(self, attr):
        video = self.__control.video()
        attr.set_value(video.getExposure())

    def write_video_exposure(self, attr):
        video = self.__control.video()
        data = attr.get_write_value()
        video.setExposure(data)

    def read_video_gain(self, attr):
        video = self.__control.video()
        attr.set_value(video.getGain())

    def write_video_gain(self, attr):
        video = self.__control.video()
        data = attr.get_write_value()
        video.setGain(data)

    def read_video_bin(self, attr):
        video = self.__control.video()
        binValue = video.getBin()

        attr.set_value([binValue.getX(), binValue.getY()], 2)

    def write_video_bin(self, attr):
        data = attr.get_write_value()

        video = self.__control.video()
        binValue = Core.Bin(*data)
        video.setBin(binValue)

    def read_video_roi(self, attr):
        video = self.__control.video()
        roi = video.getRoi()
        point = roi.getTopLeft()
        size = roi.getSize()

        attr.set_value([point.x, point.y, size.getWidth(), size.getHeight()])

    def write_video_roi(self, attr):
        data = attr.get_write_value()
        video = self.__control.video()
        roi = Core.Roi(*data)
        video.setRoi(roi)

    def read_video_last_image(self, attr):
        video = self.__control.video()
        self._videoStr = _video_image_2_struct(video.getLastImage())
        attr.set_value("VIDEO_IMAGE", self._videoStr)

    def read_video_last_image_counter(self, attr):
        video = self.__control.video()
        attr.set_value(video.getLastImageCounter())

    def read_plugin_type_list(self, attr):
        className2deviceName = get_sub_devices()
        attr.set_value(
            [x.lower().replace("deviceserver", "") for x in className2deviceName.keys()]
        )

    def read_plugin_list(self, attr):
        returnList = []
        for key, value in six.iteritems(get_sub_devices()):
            returnList.append(key.lower().replace("deviceserver", ""))
            returnList.append(value)
        attr.set_value(returnList)

    def read_shared_memory_names(self, attr):
        try:
            shared_memory = self.__control.display()
            shared_memory_names = shared_memory.getNames()
        except Exception:
            shared_memory_names = ["", ""]
        attr.set_value(shared_memory_names)

    def write_shared_memory_names(self, attr):
        self.__shared_memory_names = attr.get_write_value()
        try:
            shared_memory = self.__control.display()
            shared_memory.setNames(*self.__shared_memory_names)
        except Exception:
            pass

    def read_shared_memory_active(self, attr):
        try:
            shared_memory = self.__control.display().isActive()
        except Exception:
            shared_memory = False
        attr.set_value(shared_memory)

    def write_shared_memory_active(self, attr):
        data = attr.get_write_value()
        try:
            self.__control.display().setActive(data)
        except Exception:
            pass

    def read_config_available_module(self, attr):
        config = self.__control.config()
        attr.set_value(config.getAvailableModule())

    def read_config_available_name(self, attr):
        config = self.__control.config()
        attr.set_value(config.getAlias())

    def read_shutter_ctrl_is_available(self, attr):
        is_available = self.__control.shutter().hasCapability()
        attr.set_value(is_available)

    @RequiresSystemFeature("Core.BufferHelper.Parameters")
    def readBufferParam(self, attr, param=None, getter=None, setter=None):
        buffer_param = getter()
        val = getattr(buffer_param, param)
        if param in self.__BufferHelperEnums:
            val = getDictKey(self.__BufferHelperEnums[param], val)
        attr.set_value(val)

    @RequiresSystemFeature("Core.BufferHelper.Parameters")
    def writeBufferParam(self, attr, param=None, getter=None, setter=None):
        buffer_param = getter()
        param_name = ''.join([p.title() if i else p
                              for i, p in enumerate(param.split("_"))])
        val = attr.get_write_value()
        if param in self.__BufferHelperEnums:
            val = getDictValue(self.__BufferHelperEnums[param], val)
        setattr(buffer_param, param_name, val)
        setter(buffer_param)


    # ==================================================================
    #
    #    LimaCCDs command methods
    #
    # ==================================================================
    # ------------------------------------------------------------------
    #    getAttrStringValueList command:
    #
    #    Description: return a list of authorized values if any
    #    argout: DevVarStringArray
    # ------------------------------------------------------------------
    @Core.DEB_MEMBER_FUNCT
    def getAttrStringValueList(self, attr_name):
        valueList = []
        if attr_name == "shutter_mode":
            shutter = self.__control.shutter()
            if shutter.hasCapability():
                # Depending of the camera only a subset of the mode list can be supported
                values = shutter.getModeList()
                valueList = [getDictKey(self.__ShutterMode, val) for val in values]
        elif attr_name == "video_mode":
            video = self.__control.video()
            values = video.getSupportedVideoMode()
            valueList = [getDictKey(self.__VideoMode, val) for val in values]
        elif attr_name == "acq_trigger_mode":
            acq = self.__control.acquisition()
            try:
                values = acq.getTriggerModeList()
                valueList = [getDictKey(self.__AcqTriggerMode, val) for val in values]
            except Exception:
                valueList = list(self.__AcqTriggerMode.keys())
        elif attr_name == "saving_format":
            return self.__SavingFormat
        else:
            dict_name = (
                "_"
                + self.__class__.__name__
                + "__"
                + "".join([x.title() for x in attr_name.split("_")])
            )
            d = getattr(self, dict_name, None)
            if d:
                valueList = list(d.keys())

        return valueList

    ##@brief prepare an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def prepareAcq(self):
        self.__control.prepareAcq()
        self._push_status()

        # check that the tag is different from previous acq (if not AcqTagNone)
        tag = self.acq_tag
        if tag == self.AcqTagNone or tag != self.last_acq_tag:
            self.last_acq_tag = tag
            deb.Trace("Preparing a new acq. with tag %s (0x%08x)" % (tag, tag))
        else:
            deb.Warning("Preparing a new acq. with the same tag %s (0x%08x)" %
                        (tag, tag))

    ##@brief pushing the acquisition status
    def _push_status(self):
        status = self.__control.getStatus()
        self.push_change_event("acq_status", _acqstate2string(status.AcquisitionStatus))

    ##@brief start an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def startAcq(self):
        self.__control.startAcq()
        self._push_status()

    ##@brief stop an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def stopAcq(self):
        self.__control.stopAcq()
        self._push_status()

    ##@brief abort an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def abortAcq(self):
        self.__control.abortAcq()
        self._push_status()

    ##@brief reset acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def reset(self):
        self.__control.reset()
        # reapply default config
        if self.__configDefaultActiveFlag:
            config = self.__control.config()
            config.apply(self.ConfigurationDefaultName)
        self._push_status()

    ##@brief set images heaaders
    #
    @Core.DEB_MEMBER_FUNCT
    def setImageHeader(self, headers_str):
        control = self.__control
        saving = control.saving()
        for image_header in headers_str:
            imageIdSepPos = image_header.find(self.__image_number_header_delimiter)
            imageId = int(image_header[:imageIdSepPos])
            header_str = image_header[imageIdSepPos + 1 :]
            deb.Param("Setting to image %d file header: %s" % (imageId, header_str))
            header_map = {}
            for line in header_str.split(self.__entry_header_delimiter):
                token = line.split(self.__key_header_delimiter)
                key = token[0].strip()
                if not key:
                    continue
                try:
                    val = "=".join(token[1:]).strip()
                except ValueError:
                    continue
                if val.endswith(";"):
                    val = val[:-1]
                header_map[key] = val
            saving.updateFrameHeader(imageId, header_map)

    ##@brief reset common header
    #
    @Core.DEB_MEMBER_FUNCT
    def resetCommonHeader(self):
        control = self.__control
        saving = control.saving()
        saving.resetCommonHeader()

    ##@brief reset frames header
    #
    @Core.DEB_MEMBER_FUNCT
    def resetFrameHeaders(self):
        control = self.__control
        saving = control.saving()
        saving.removeAllFrameHeaders()

    ##@brief get image data
    #
    @Core.DEB_MEMBER_FUNCT
    def getImage(self, image_id):
        data = self.__control.ReadImage(image_id)
        self.__dataflat_cache = numpy.array(data.buffer.ravel())
        self.__dataflat_cache.dtype = numpy.uint8
        release = getattr(data, "releaseBuffer", None)
        if release:
            release()
        return self.__dataflat_cache

    ##@brief get a DATA_ARRAY from a Data object
    #
    @Core.DEB_MEMBER_FUNCT
    def _image_2_data_array(self, data, category):
        d = data.buffer
        s = [d.shape[i] for i in range(len(d.shape) - 1, -1, -1)]
        if (category == self.DataArrayCategory.ImageStack) and (len(s) == 2):
            s += [1]
        nbDim = len(s)
        maxNbDim = self.DataArrayMaxNbDim
        if nbDim > maxNbDim:
            raise ValueError("Invalid nb of dimensions: max is %d" % maxNbDim)

        image = self.__control.image()
        imageType = image.getImageType()
        dataType = self.ImageType2DataArrayType.get(imageType, -1)
        bigEndian = numpy.dtype(d.dtype.byteorder + "i4") == numpy.dtype(">i4")
        imageNumber = data.frameNumber
        acqTag = self.last_acq_tag

        def steps_gen(s):
            size = self.ImageType2NbBytes.get(imageType, (1, 0))[0]
            for x in s:
                yield size
                size *= x

        t = [i for i in steps_gen(s)]

        s += [0] * (maxNbDim - nbDim)
        t += [0] * (maxNbDim - nbDim)

        # verify backward compatibility
        headerlen = struct.calcsize(self.DataArrayPackStr)
        if headerlen < self.DataArrayMinHeaderLen:
            raise RuntimeError(
                "Invalid header len: %d (min. expected %d)"
                % (headerlen, self.DataArrayMinHeaderLen)
            )

        # prepare the structure
        dataheader = struct.pack(
            self.DataArrayPackStr,
            self.DataArrayMagic,  # 4 bytes I - magic number
            self.DataArrayVersion,  # 2 bytes H - version
            headerlen,  # 2 bytes H - this header length
            category,  # 4 bytes I - category (enum)
            dataType,  # 4 bytes I - data type (enum)
            bigEndian,  # 2 bytes H - endianness
            nbDim,  # 2 bytes H - nb of dims
            s[0],
            s[1],
            s[2],
            s[3],
            s[4],
            s[5],  # 12 bytes H x 6 - dims
            t[0],
            t[1],
            t[2],
            t[3],
            t[4],
            t[5],  # 24 bytes I x 6 - stepsbytes
            imageNumber,  # 8 bytes Q x 1 - imageNumber
            acqTag,  # 8 bytes Q x 1 - acqTag
            0, 0,  # 8 bytes I x 2 - pading
        )

        flatData = d.ravel()
        flatData.dtype = numpy.uint8

        dataStr = dataheader + flatData.tostring()
        release = getattr(data, "releaseBuffer", None)
        if release:
            release()

        return dataStr

    ##@brief get image data
    #
    @Core.DEB_MEMBER_FUNCT
    def readImage(self, frame_number):
        deb.Param("readImage: frame_number=%d" % frame_number)
        image = self.__control.ReadImage(frame_number)
        category = self.DataArrayCategory.Image
        self._datacache = self._image_2_data_array(image, category)
        return ("DATA_ARRAY", self._datacache)
        
    ##@brief get last image data (if new image since last_frame_number)
    #
    # @returns Image if new image available since last_frame_number else None
    @Core.DEB_MEMBER_FUNCT
    def readLastImage(self, last_frame_number=-1):
        deb.Param("readLastImage: last_frame_number=%d" % last_frame_number)
        status = self.__control.getStatus()
        last_img_ready = status.ImageCounters.LastImageReady
        if last_img_ready <= last_frame_number:
            deb.Trace(f"No newer image available")
            PyTango.Except.throw_exception(PyTango.DevError(
                desc="Frame(s) not available yet",
                #tango.ErrSeverity.ERR,
                #"readLastImage()",
            ))
        else:
            image = self.__control.ReadImage(-1)
            category = self.DataArrayCategory.Image
            self._datacache = self._image_2_data_array(image, category)
            return ("DATA_ARRAY", self._datacache)

    ##@brief get the data for an image sequence
    #
    # @params start,end[,step[,acq_tag]]
    @Core.DEB_MEMBER_FUNCT
    def readImageSeq(self, frame_seq):
        deb.Param("frame_seq=%s" % frame_seq)
        frame_seq = [int(f) for f in frame_seq]
        start, end = frame_seq[:2]
        step = 1
        acq_tag = self.AcqTagNone
        nb_args = len(frame_seq)
        if nb_args > 2:
            step = frame_seq[2]
            if step != 1:
                raise ValueError("Discontiguous sequences not supported yet")
        if nb_args > 3:
            acq_tag = frame_seq[3] & 0xffffffff
            if acq_tag != self.AcqTagNone:
                if self.last_acq_tag == self.AcqTagNone:
                    raise RuntimeError("No acq_tag has been set yet")
                elif acq_tag != self.last_acq_tag:
                    raise RuntimeError("Acq. #%s (0x%08x) is not available" %
                                       (acq_tag, acq_tag))
        nbFrames = end - start
        deb.Param(
            "readImageSeq: start,end,step = %d,%d,%d (%d frames), "
            "acq_tag = %s (0x%08x) " %
            (start, end, step, nbFrames, acq_tag, acq_tag)
        )
        imageStack = self.__control.ReadImage(start, nbFrames)
        category = self.DataArrayCategory.ImageStack
        self._dataseqcache = self._image_2_data_array(imageStack, category)
        return ("DATA_ARRAY", self._dataseqcache)

    ##@brief get base image data
    #
    # image before post processing
    @Core.DEB_MEMBER_FUNCT
    def getBaseImage(self, image_id):
        data = self.__control.ReadBaseImage(image_id)
        self.__dataflat_cache = numpy.array(data.buffer.ravel())
        self.__dataflat_cache.dtype = numpy.uint8
        return self.__dataflat_cache

    ##@brief manual write image
    #
    #
    @Core.DEB_MEMBER_FUNCT
    def writeImage(self, image_id):
        saving = self.__control.saving()
        saving.writeFrame(image_id)

    ##@brief get saturated images
    #
    # @params image_id if < 0 read the last image
    @Core.DEB_MEMBER_FUNCT
    def readAccSaturatedImageCounter(self, image_id):
        acc = self.__control.accumulation()
        saturated_image = acc.readSaturatedImageCounter(image_id)
        self.__arr_cache = []
        if saturated_image.buffer is not None:
            self.__arr_cache = numpy.array(saturated_image.buffer)
            self.__arr_cache = self.__arr_cache.ravel()
        return self.__arr_cache

    ##@brief get saturated sum counter
    #
    # @params from_image_id the starting image id
    @Core.DEB_MEMBER_FUNCT
    def readAccSaturatedSumCounter(self, from_image_id):
        acc = self.__control.accumulation()
        sumCounters = acc.readSaturatedSumCounter(from_image_id)
        returnList = []
        if sumCounters:
            number_of_counters_per_image = len(sumCounters[0])
            returnList = list(itertools.chain(*sumCounters))
            returnList.insert(0, number_of_counters_per_image)
        return returnList

    ##@brief set the mask file for saturated counters
    #
    # @params file_path the full path of mask image or '' -> unset Mask
    @Core.DEB_MEMBER_FUNCT
    def setAccSaturatedMask(self, file_path):
        if file_path:
            f = EdfFile.EdfFile(file_path)
            d = f.GetData(0)
            data = Core.Processlib.Data()
            data.buffer = d
        else:  # UNSET MASK
            data = Core.Processlib.Data()
        acc = self.__control.accumulation()
        acc.setMask(data)

    # ------------------------------------------------------------------
    #    closeShutterManual command:
    #
    #    Description: Close the shutter manual
    #    argout: DevVoid
    # ------------------------------------------------------------------
    @Core.DEB_MEMBER_FUNCT
    def closeShutterManual(self):

        shutter = self.__control.shutter()

        if shutter.getModeList().count(Core.ShutterManual):
            shutter.setState(False)

    # ------------------------------------------------------------------
    #    openShutterManual command:
    #
    #    Description: Open the shutter manual
    #    argout: DevVoid
    # ------------------------------------------------------------------
    @Core.DEB_MEMBER_FUNCT
    def openShutterManual(self):

        shutter = self.__control.shutter()

        if shutter.getModeList().count(Core.ShutterManual):
            shutter.setState(True)

    @Core.DEB_MEMBER_FUNCT
    def getPluginDeviceNameFromType(self, pluginType):
        pluginType2deviceName = dict(
            [
                (x.lower().replace("deviceserver", ""), y)
                for x, y in six.iteritems(get_sub_devices())
            ]
        )
        return pluginType2deviceName.get(pluginType.lower(), "")

    # ----------------------------------------------------------------------------
    #                         Configuration Mgt
    # ----------------------------------------------------------------------------
    @Core.DEB_MEMBER_FUNCT
    def configStore(self, args):
        config_name = args.pop(0)
        config = self.__control.config()
        config.store(config_name, args)

    @Core.DEB_MEMBER_FUNCT
    def configApply(self, config_name):
        config = self.__control.config()
        config.apply(config_name)

    @Core.DEB_MEMBER_FUNCT
    def configPop(self, config_name):
        config = self.__control.config()
        config.pop(config_name)

    @Core.DEB_MEMBER_FUNCT
    def configDelete(self, config_name):
        config = self.__control.config()
        config.remove(config_name)

    @Core.DEB_MEMBER_FUNCT
    def configFileSave(self):
        config = self.__control.config()
        config.save()

    @Core.DEB_MEMBER_FUNCT
    def configFileLoad(self):
        config = self.__control.config()
        config.load()

    @Core.DEB_MEMBER_FUNCT
    def setSavingStream(self, streamNb):
        self.__SavingStream = streamNb


# ==================================================================
#
#    LimaCCDsClass class definition
#
# ==================================================================
class LimaCCDsClass(PyTango.DeviceClass):
    #    Class Properties
    class_property_list = {}

    #    Device Properties
    device_property_list = {
        "LimaCameraType": [PyTango.DevString, "Camera Plugin name", []],
        "NbProcessingThread": [
            PyTango.DevString,
            "Number of thread for processing",
            [2],
        ],
        "AccBufferParameters": [
            PyTango.DevString,
            "Accumulation Buffer alloc. params: "
            "<initMem=0|1, durationPolicy=EPHEMERAL|PERSISTENT, sizePolicy=AUTOMATIC|FIXED, reqMemSizePercent=0.0-100.0>",
            [''],
        ],
        "AccThresholdCallbackModule": [
            PyTango.DevString,
            "Plugin name file which manage threshold",
            [],
        ],
        "ConfigurationFilePath": [
            PyTango.DevString,
            "Configuration file path",
            [os.path.join(os.path.expanduser("~"), "lima_%s.cfg" % instance_name)],
        ],
        "ConfigurationDefaultName": [
            PyTango.DevString,
            "Default configuration name",
            ["default"],
        ],
        "ImageOpMode": [
            PyTango.DevString,
            "Configure the image op mode. One of 'HardOnly', 'SoftOnly', 'HardAndSoft'.",
            [],
        ],
        "MaxVideoFPS": [PyTango.DevDouble, "Maximum number of FPS for video", [30.0]],
        "UserDetectorName": [
            PyTango.DevString,
            "A user detector identifier, e.g frelon-saxs",
            [],
        ],
        "UserInstrumentName": [
            PyTango.DevString,
            "The instrument name, e.g ESRF-ID02",
            [],
        ],
        "BufferMaxMemory": [
            PyTango.DevString,
            "The maximum among of memory (RAM) Lima should use to allocate the frame buffers, e.g 50 %, default is 70%",
            [],
        ],
        "BufferAllocParameters": [
            PyTango.DevString,
            "HW Buffer alloc. params: "
            "<initMem=0|1, durationPolicy=EPHEMERAL|PERSISTENT, sizePolicy=AUTOMATIC|FIXED, reqMemSizePercent=0.0-100.0> [default: <initMem=1, reqMemSizePercent=70.0>]",
            [''],
        ],
        "TangoEvent": [PyTango.DevBoolean, "Activate Tango event", [False]],
        "SavingMaxConcurrentWritingTask": [
            PyTango.DevShort,
            "Maximum concurrent writing tasks",
            [1],
        ],
        "SavingZBufferParameters": [
            PyTango.DevString,
            "Saving ZBuffer alloc. params: "
            "<initMem=0|1, durationPolicy=EPHEMERAL|PERSISTENT, sizePolicy=AUTOMATIC|FIXED, reqMemSizePercent=0.0-100.0>",
            [''],
        ],
    }

    #    Command definitions
    cmd_list = {
        "gc": [[PyTango.DevVoid, ""], [PyTango.DevVoid, ""]],
        "openShutterManual": [[PyTango.DevVoid, ""], [PyTango.DevVoid, ""]],
        "closeShutterManual": [[PyTango.DevVoid, ""], [PyTango.DevVoid, ""]],
        "getAttrStringValueList": [
            [PyTango.DevString, "Attribute name"],
            [PyTango.DevVarStringArray, "Authorized String value list"],
        ],
        "prepareAcq": [[PyTango.DevVoid, ""], [PyTango.DevVoid, ""]],
        "startAcq": [[PyTango.DevVoid, ""], [PyTango.DevVoid, ""]],
        "stopAcq": [[PyTango.DevVoid, ""], [PyTango.DevVoid, ""]],
        "abortAcq": [[PyTango.DevVoid, ""], [PyTango.DevVoid, ""]],
        "reset": [[PyTango.DevVoid, ""], [PyTango.DevVoid, ""]],
        "setImageHeader": [
            [
                PyTango.DevVarStringArray,
                "ImageId0 SEPARATOR imageHeader0,ImageId1 SEPARATOR imageHeader1...",
            ],
            [PyTango.DevVoid, ""],
        ],
        "resetCommonHeader": [[PyTango.DevVoid, ""], [PyTango.DevVoid, ""]],
        "resetFrameHeaders": [[PyTango.DevVoid, ""], [PyTango.DevVoid, ""]],
        "getImage": [
            [PyTango.DevLong, "The image number"],
            [PyTango.DevVarCharArray, "The data image"],
        ],
        "getBaseImage": [
            [PyTango.DevLong, "The image number"],
            [PyTango.DevVarCharArray, "The base data image"],
        ],
        "readAccSaturatedImageCounter": [
            [PyTango.DevLong, "The image number"],
            [PyTango.DevVarUShortArray, "The image counter"],
        ],
        "readAccSaturatedSumCounter": [
            [PyTango.DevLong, "From image id"],
            [
                PyTango.DevVarLongArray,
                "number of result for each images,sum counter of raw image #0 of image #0,sum counter of raw image #1 of image #0,...",
            ],
        ],
        "setAccSaturatedMask": [
            [PyTango.DevString, "Full path of mask file"],
            [PyTango.DevVoid, ""],
        ],
        "writeImage": [[PyTango.DevLong, "Image id"], [PyTango.DevVoid, ""]],
        "readImage": [
            [PyTango.DevLong, "Image id"],
            [PyTango.DevEncoded, "DATA_ARRAY with requested image"],
        ],
        "readLastImage": [
            [PyTango.DevLong, "Last image id"],
            [PyTango.DevEncoded, "DATA_ARRAY with requested image"],
        ],
        "readImageSeq": [
            [PyTango.DevVarLong64Array, "Image id seq: start,end[,step[,acq_tag]]"],
            [PyTango.DevEncoded, "DATA_ARRAY with requested images"],
        ],
        "getPluginDeviceNameFromType": [
            [PyTango.DevString, "plugin type"],
            [PyTango.DevString, "device name"],
        ],
        "configStore": [
            [PyTango.DevVarStringArray, "config name,module1,module2,...,modulen"],
            [PyTango.DevVoid, ""],
        ],
        "configApply": [[PyTango.DevString, "config name"], [PyTango.DevVoid, ""]],
        "configPop": [[PyTango.DevString, "config name"], [PyTango.DevVoid, ""]],
        "configDelete": [[PyTango.DevString, "config name"], [PyTango.DevVoid, ""]],
        "configFileSave": [[PyTango.DevVoid, ""], [PyTango.DevVoid, ""]],
        "configFileLoad": [[PyTango.DevVoid, ""], [PyTango.DevVoid, ""]],
        "setSavingStream": [[PyTango.DevLong, "Stream number"], [PyTango.DevVoid, ""]],
    }

    #    Attribute definitions
    attr_list = {
        "lima_version": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ]],
        "lima_type": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ]],
        "camera_type": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ]],
        "camera_model": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ]],
        "user_detector_name": [
            [PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE],
            {
                "label": "user detector name",
                "description": "A user defined detector name, will be saved in the saved file header",
            },
        ],
        "user_instrument_name": [
            [PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE],
            {
                "label": "instrument/beamline name",
                "description": "the instrument/beamline name, will be saved in the saved file header",
            },
        ],
        "camera_pixelsize": [
            [PyTango.DevDouble, PyTango.SPECTRUM, PyTango.READ, 2],
            {
                "label": "Pixel size:x_size, y_size",
                "unit": "meter",
                "standard unit": "meter",
                "display unit": "meter",
                "format": "%f",
                "description": "Size of the pixel in meter",
            },
        ],
        "acq_status": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ]],
        "acq_status_fault_error": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ]],
        "acq_tag": [[PyTango.DevULong64, PyTango.SCALAR, PyTango.READ_WRITE]],
        "acc_expo_time": [[PyTango.DevDouble, PyTango.SCALAR, PyTango.READ]],
        "acc_nb_frames": [[PyTango.DevLong, PyTango.SCALAR, PyTango.READ]],
        "acc_dead_time": [[PyTango.DevDouble, PyTango.SCALAR, PyTango.READ]],
        "acc_live_time": [[PyTango.DevDouble, PyTango.SCALAR, PyTango.READ]],
        "acc_saturated_active": [
            [PyTango.DevBoolean, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "acc_saturated_threshold": [
            [PyTango.DevLong, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "acc_saturated_cblevel": [
            [PyTango.DevLong, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "acc_buffer_init_mem": [
            [PyTango.DevBoolean, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "acc_buffer_duration_policy": [
            [PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "acc_buffer_size_policy": [
            [PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "acc_buffer_req_mem_size_percent": [
            [PyTango.DevDouble, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "acq_mode": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]],
        "acc_time_mode": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]],
        "acq_nb_frames": [[PyTango.DevLong, PyTango.SCALAR, PyTango.READ_WRITE]],
        "acq_expo_time": [[PyTango.DevDouble, PyTango.SCALAR, PyTango.READ_WRITE]],
        "acc_max_expo_time": [[PyTango.DevDouble, PyTango.SCALAR, PyTango.READ_WRITE]],
        "acc_mode": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]],
        "acc_filter": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]],
        "acc_operation": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]],
        "acc_threshold_before": [[PyTango.DevLong, PyTango.SCALAR, PyTango.READ_WRITE]],
        "acc_offset_before": [[PyTango.DevLong, PyTango.SCALAR, PyTango.READ_WRITE]],
        "acc_out_type": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]],
        "acc_hw_nb_buffers": [[PyTango.DevLong, PyTango.SCALAR, PyTango.READ_WRITE]],
        "concat_nb_frames": [[PyTango.DevLong, PyTango.SCALAR, PyTango.READ_WRITE]],
        "latency_time": [[PyTango.DevDouble, PyTango.SCALAR, PyTango.READ_WRITE]],
        "valid_ranges": [
            [PyTango.DevDouble, PyTango.SPECTRUM, PyTango.READ, 4],
            {
                "label": "valid time ranges: min_exposure, max_exposure, min_latency, max_latency",
                "unit": "second",
                "standard unit": "second",
                "display unit": "second",
                "format": "%f",
                "description": "min_exposure, max_exposure, min_latency, max_latency",
            },
        ],
        "acq_trigger_mode": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]],
        "image_roi": [[PyTango.DevLong, PyTango.SPECTRUM, PyTango.READ_WRITE, 4]],
        "image_sizes": [
            [PyTango.DevULong, PyTango.SPECTRUM, PyTango.READ, 4],
            {
                "label": "Image sizes:Signed, Depth, Width, Height",
                "unit": "",
                "standard unit": "",
                "display unit": "",
                "format": "%d",
                "description": "Signed ,nb bytes of depth, nb pixels of width and nb pixels of height",
            },
        ],
        "image_max_dim": [
            [PyTango.DevULong, PyTango.SPECTRUM, PyTango.READ, 2],
            {
                "label": "Width, Height",
                "unit": "pixel",
                "format": "%d",
                "description": "Max width and height in pixel",
            },
        ],
        "image_type": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ]],
        "image_width": [[PyTango.DevULong, PyTango.SCALAR, PyTango.READ]],
        "image_height": [[PyTango.DevULong, PyTango.SCALAR, PyTango.READ]],
        "image_bin": [[PyTango.DevULong, PyTango.SPECTRUM, PyTango.READ_WRITE, 2]],
        "image_flip": [[PyTango.DevBoolean, PyTango.SPECTRUM, PyTango.READ_WRITE, 2]],
        "image_rotation": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]],
        "last_image_acquired": [[PyTango.DevLong, PyTango.SCALAR, PyTango.READ]],
        "last_base_image_ready": [[PyTango.DevLong, PyTango.SCALAR, PyTango.READ]],
        "last_image_ready": [[PyTango.DevLong, PyTango.SCALAR, PyTango.READ]],
        "last_image": [[PyTango.DevEncoded, PyTango.SCALAR, PyTango.READ]],
        "last_image_saved": [[PyTango.DevLong, PyTango.SCALAR, PyTango.READ]],
        "last_counter_ready": [[PyTango.DevLong, PyTango.SCALAR, PyTango.READ]],
        "image_events_push_data": [
            [PyTango.DevBoolean, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "image_events_max_rate": [
            [PyTango.DevFloat, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "ready_for_next_image": [[PyTango.DevBoolean, PyTango.SCALAR, PyTango.READ]],
        "ready_for_next_acq": [[PyTango.DevBoolean, PyTango.SCALAR, PyTango.READ]],
        "saving_directory": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]],
        "saving_prefix": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]],
        "saving_suffix": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]],
        "saving_next_number": [[PyTango.DevLong, PyTango.SCALAR, PyTango.READ_WRITE]],
        "saving_format": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]],
        "saving_mode": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]],
        "saving_managed_mode": [
            [PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "saving_overwrite_policy": [
            [PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "saving_use_hw_comp": [
            [PyTango.DevBoolean, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "saving_frame_per_file": [
            [PyTango.DevLong, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "saving_every_n_frames": [
            [PyTango.DevLong, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "saving_common_header": [
            [PyTango.DevString, PyTango.SPECTRUM, PyTango.READ_WRITE, 65535]
        ],
        "saving_header_delimiter": [
            [PyTango.DevString, PyTango.SPECTRUM, PyTango.READ_WRITE, 3]
        ],
        "saving_index_format": [
            [PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "saving_statistics": [[PyTango.DevDouble, PyTango.SPECTRUM, PyTango.READ, 4]],
        "saving_statistics_history": [
            [PyTango.DevLong, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "saving_statistics_log_enable": [
            [PyTango.DevBoolean, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "saving_max_writing_task": [
            [PyTango.DevShort, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "saving_stream_active": [
            [PyTango.DevBoolean, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "saving_zbuffer_init_mem": [
            [PyTango.DevBoolean, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "saving_zbuffer_duration_policy": [
            [PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "saving_zbuffer_size_policy": [
            [PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "saving_zbuffer_req_mem_size_percent": [
            [PyTango.DevDouble, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "debug_modules_possible": [
            [
                PyTango.DevString,
                PyTango.SPECTRUM,
                PyTango.READ,
                len(LimaCCDs._debugModuleList),
            ]
        ],
        "debug_modules": [
            [
                PyTango.DevString,
                PyTango.SPECTRUM,
                PyTango.READ_WRITE,
                len(LimaCCDs._debugModuleList),
            ]
        ],
        "debug_types_possible": [
            [
                PyTango.DevString,
                PyTango.SPECTRUM,
                PyTango.READ,
                len(LimaCCDs._debugTypeList),
            ]
        ],
        "debug_types": [
            [
                PyTango.DevString,
                PyTango.SPECTRUM,
                PyTango.READ_WRITE,
                len(LimaCCDs._debugTypeList),
            ]
        ],
        "video_active": [[PyTango.DevBoolean, PyTango.SCALAR, PyTango.READ_WRITE]],
        "video_live": [[PyTango.DevBoolean, PyTango.SCALAR, PyTango.READ_WRITE]],
        "video_exposure": [[PyTango.DevDouble, PyTango.SCALAR, PyTango.READ_WRITE]],
        "video_gain": [[PyTango.DevDouble, PyTango.SCALAR, PyTango.READ_WRITE]],
        "video_mode": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]],
        "video_source": [[PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]],
        "video_roi": [[PyTango.DevLong, PyTango.SPECTRUM, PyTango.READ_WRITE, 4]],
        "video_bin": [[PyTango.DevULong, PyTango.SPECTRUM, PyTango.READ_WRITE, 2]],
        "video_last_image": [
            [PyTango.DevEncoded, PyTango.SCALAR, PyTango.READ],
            {
                "label": "the video image",
                "unit": "",
                "standard unit": "",
                "display unit": "",
                "format": "%d",
                "description": "video image as encoded",
            },
        ],
        "video_last_image_counter": [[PyTango.DevLong64, PyTango.SCALAR, PyTango.READ]],
        "plugin_type_list": [[PyTango.DevString, PyTango.SPECTRUM, PyTango.READ, 256]],
        "plugin_list": [[PyTango.DevString, PyTango.SPECTRUM, PyTango.READ, 256]],
        "shared_memory_names": [
            [PyTango.DevString, PyTango.SPECTRUM, PyTango.READ_WRITE, 2]
        ],
        "shared_memory_active": [
            [PyTango.DevBoolean, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "config_available_module": [
            [PyTango.DevString, PyTango.SPECTRUM, PyTango.READ, 1024]
        ],
        "config_available_name": [
            [PyTango.DevString, PyTango.SPECTRUM, PyTango.READ, 1024]
        ],
        "buffer_alloc_init_mem": [
            [PyTango.DevBoolean, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "buffer_alloc_duration_policy": [
            [PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "buffer_alloc_size_policy": [
            [PyTango.DevString, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "buffer_alloc_req_mem_size_percent": [
            [PyTango.DevDouble, PyTango.SCALAR, PyTango.READ_WRITE]
        ],
        "buffer_max_number": [[PyTango.DevLong, PyTango.SCALAR, PyTango.READ]],
        "shutter_ctrl_is_available": [
            [PyTango.DevBoolean, PyTango.SCALAR, PyTango.READ]
        ],
    }


def declare_camera_n_commun_to_tango_world(util):
    warningFlag = False
    for module_name in camera.__all__:
        try:
            if LimaCameraType and (module_name != LimaCameraType):
                continue
            m = get_camera_module(module_name)
        except Exception:
            print(
                "Warning optional camera %s can't be load, dependency not satisfied."
                % module_name
            )
            warningFlag = True
            if verboseLevel >= 4:
                import traceback

                traceback.print_exc()
                print()
            continue
        else:
            try:
                func = getattr(m, "get_tango_specific_class_n_device")
                class_info = func()
            except AttributeError:
                pass
            else:
                if isinstance(class_info, (list, tuple)):
                    specificClass, specificDevice = class_info
                else:
                    specificClass, specificDevice = (
                        class_info.TangoClassClass,
                        class_info,
                    )
                util.add_class(specificClass, specificDevice)
            try:
                func = getattr(m, "get_taco_specific_cmd_list_n_proxy_cont")
                cmd_list, proxy_cont = func()
                TacoSpecificDict[module_name] = cmd_list, proxy_cont
            except AttributeError:
                pass
    if warningFlag and verboseLevel < 4:
        print("For more camera dependency information start server with -v4")

    warningFlag = False
    for module_name in plugins.__all__:
        try:
            m = get_plugin_module(module_name)
        except Exception:
            print(
                "Warning optional plugin %s can't be load, dependency not satisfied."
                % module_name
            )
            warningFlag = True
            if verboseLevel >= 4:
                import traceback

                traceback.print_exc()
                print()
            continue
        else:
            if "Taco" in module_name:
                try:
                    func = getattr(m, "set_taco_specific_dict_n_name_cont")
                    func(TacoSpecificDict, TacoSpecificName)
                except AttributeError:
                    pass
            try:
                func = getattr(m, "get_tango_specific_class_n_device")
            except AttributeError:
                continue
            else:
                class_info = func()
                if isinstance(class_info, (list, tuple)):
                    specificClass, specificDevice = class_info
                else:
                    specificClass, specificDevice = (
                        class_info.TangoClassClass,
                        class_info,
                    )
                util.add_class(specificClass, specificDevice)
    if warningFlag and verboseLevel < 4:
        print("For more plugins dependency information start server with -v4")


def export_default_plugins():
    # Post processing tango export
    util = PyTango.Util.instance()
    className2deviceName = get_sub_devices()
    masterDeviceName = className2deviceName.get("LimaCCDs", None)
    if masterDeviceName:
        beamlineName, _, cameraName = masterDeviceName.split("/")
        for module_name in plugins.__all__:
            try:
                m = get_plugin_module(module_name)
            except ImportError:
                continue
            else:
                try:
                    (
                        specificClass,
                        specificDevice,
                    ) = m.get_tango_specific_class_n_device()
                except AttributeError:
                    continue

                deviceName = className2deviceName.get(specificDevice.__name__, None)
                # only create one if not exist
                if deviceName is None and specificClass and specificDevice:
                    deviceName = "%s/%s/%s" % (
                        beamlineName,
                        specificDevice.__name__.lower().replace("deviceserver", ""),
                        cameraName,
                    )
                    print("create device", specificDevice.__name__, deviceName)
                    try:
                        util.create_device(specificDevice.__name__, deviceName)
                    except Exception:
                        import traceback

                        traceback.print_exc()


def _set_control_ref(ctrl_ref):
    for module_name in plugins.__all__:
        try:
            m = get_plugin_module(module_name)
        except ImportError:
            continue
        else:
            try:
                func = getattr(m, "set_control_ref")
                func(ctrl_ref)
            except AttributeError:
                continue


# ============================================================================
#                                TOOLS
# ============================================================================
def _getLastFileNumber(prefix, suffix, filesPath):
    lastNumber = -1
    prefixLen = len(prefix)
    lenSuffix = len(suffix)

    for fPath in filesPath:
        fName = os.path.split(fPath)[-1]
        number = fName[prefixLen:-lenSuffix]
        try:
            number = int(number)
        except ValueError:
            continue
        else:
            if number > lastNumber:
                lastNumber = number
    return lastNumber


def _allowed(*args):
    return True


def _not_allowed(*args):
    return False


def _video_image_2_struct(image):
    VIDEO_HEADER_FORMAT = "!IHHqiiHHHH"
    videoheader = struct.pack(
        VIDEO_HEADER_FORMAT,
        0x5644454F,  # Magic
        1,  # header version
        image.mode(),  # image mode (Y8,Y16...)
        image.frameNumber(),  # frame number
        image.width(),  # width
        image.height(),  # height
        ord(struct.pack("=H", 1).decode()[-1]),  # endianness
        struct.calcsize(VIDEO_HEADER_FORMAT),  # header size
        0,
        0,
    )  # padding

    return videoheader + image.buffer()


def _acqstate2string(state):
    state2string = {
        Core.AcqReady: "Ready",
        Core.AcqRunning: "Running",
        Core.AcqFault: "Fault",
    }
    if SystemHasFeature("Core.AcqConfig"):
        state2string[Core.AcqConfig] = "Configuration"
    return state2string.get(state, "?")


def _get_control():
    global control
    try:
        return control
    except NameError:
        pass
    try:
        camera_type = LimaCameraType or get_lima_camera_type()
    except KeyError:  # wizard mode
        return None

    try:
        m = get_camera_module(camera_type)
    except ImportError:
        import traceback

        traceback.print_exc()
    else:
        properties = {}
        className2deviceName = get_sub_devices()
        try:
            class_info = m.get_tango_specific_class_n_device()
        except AttributeError:
            import traceback

            traceback.print_exc()
            pass
        else:
            if isinstance(class_info, (list, tuple)):
                _, specificDevice = class_info
            else:
                specificDevice = class_info
            typeFlagsNameList = []
            for level in range(verboseLevel + 1):
                typeFlagsNameList += VerboseLevel2TypeFlags.get(level, [])
            Core.DebParams.setTypeFlagsNameList(typeFlagsNameList)

            util = PyTango.Util.instance()
            db = util.get_database()
            deviceName = className2deviceName.get(specificDevice.__name__, None)
            if deviceName:
                propertiesNames = db.get_device_property_list(deviceName, "*")
                for pName in propertiesNames.value_string:
                    key, value = db.get_device_property(deviceName, pName).popitem()
                    if len(value) == 1:
                        value = value[0]
                    properties[key] = value

        control = m.get_control(**properties)
        _set_control_ref(weakref.ref(control))
        return control


# ==================================================================
#
#    LimaCCDs class main method
#
# ==================================================================
verboseLevel = 2


def main(args=None, event_loop=None):
    """
    Run LimaCCDs server

    Arguments:
        args: Command line arguments
        event_loop:
            Registers an event loop function in a Tango server.
            This function will be called by the process main thread in an infinite loop
            The process will not use the classical ORB blocking event loop.
            It is the user responsibility to code this function in a way that it implements
            some kind of blocking in order not to load the computer CPU. The following
            piece of code is an example of how you can use this feature::
    """
    args = list(args or sys.argv)
    args[0] = "LimaCCDs"

    global verboseLevel

    for option in args:
        if option.startswith("-v"):
            try:
                verboseLevel = int(option[2:])
            except Exception:
                pass

    try:
        py = PyTango.Util(args)
        py.add_TgClass(LimaCCDsClass, LimaCCDs, "LimaCCDs")
        try:
            declare_camera_n_commun_to_tango_world(py)
        except Exception:
            import traceback

            traceback.print_exc()

        U = PyTango.Util.instance()

        U.server_init()

        if event_loop is not None:
            U.server_set_event_loop(event_loop)

        # Configurations management (load default or custom config)
        dev = U.get_device_list_by_class("LimaCCDs")
        if dev:
            dev[0].apply_config()

        try:
            export_default_plugins()
        except Exception:
            import traceback

            traceback.print_exc()

        U.server_run()
        return 0

    except PyTango.DevFailed as e:
        print("-------> Received a DevFailed exception:", e)
        return -1
    except Exception as e:
        print("-------> An unforeseen exception occurred....", e)
        # import traceback
        # traceback.print_exc()
        return -1


if __name__ == "__main__":
    res = main()
    sys.exit(res)
