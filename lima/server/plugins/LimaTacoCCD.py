############################################################################
# This file is part of LImA, a Library for Image Acquisition
#
# Copyright (C) : 2009-2026
# European Synchrotron Radiation Facility
# CS40220 38043 Grenoble Cedex 9
# FRANCE
# Contact: lima@esrf.fr
#
# This is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>.
############################################################################
# =============================================================================
#
# file :        LimaTacoCCDs.py
#
# description : Python source for the LimaTacoCCDs and its commands.
#                The class is derived from Device. It represents the
#                CORBA servant object which will be accessed from the
#                network. All commands which can be executed on the
#         LimaTacoCCDs are implemented in this file.
#
# project :    TANGO Device Server
#
# copyleft :    European Synchrotron Radiation Facility
#        BP 220, Grenoble 38043
#        FRANCE
#
# =============================================================================
#        This file is generated by seb
#
#      (c) - BLISS - ESRF
# =============================================================================
#

import struct
import PyTango

from lima import core

import numpy

DevCcdBase = 0xC180000

# CCD States
DevCcdReady = DevCcdBase + 1
DevCcdAcquiring = DevCcdBase + 2
DevCcdFault = DevCcdBase + 3
DevCcdSaving = DevCcdBase + 4
DevCcdNotYetInitialised = DevCcdBase + 5
DevCcdInitializing = DevCcdBase + 6
DevCcdReadout = DevCcdBase + 7
DevCcdCorrecting = DevCcdBase + 8
DevCcdBusy = DevCcdBase + 9
DevCcdAborting = DevCcdBase + 10
DevCcdNoRemote = DevCcdBase + 11

# CCD Errors
DevErrCcdState = DevCcdBase + 1
DevErrCcdController = DevCcdBase + 2
DevErrCcdNotEnoughDisk = DevCcdBase + 3
DevErrCcdNoDirPermission = DevCcdBase + 4
DevErrCcdNoDirectory = DevCcdBase + 5
DevErrCcdLongPath = DevCcdBase + 6
DevErrCcdEmptyPath = DevCcdBase + 7
DevErrCcdNotAccessible = DevCcdBase + 8
DevErrCcdNoFilePermission = DevCcdBase + 9
DevErrCcdFileExist = DevCcdBase + 10
DevErrCcdCmdNotProc = DevCcdBase + 11
DevErrCcdCameraModel = DevCcdBase + 12
DevErrCcdProcessImage = DevCcdBase + 13

# ==================================================================
#   LimaTacoCCDs Class Description:
#
#      This is a device server for the LimaTacoCCDs cameras
#      and implementing the Taco ccd interface
#      for integrating it on the beamline.
#
# ==================================================================
#    Device States Description:
#
#   DevState.ON :     ccd is ON, taking pictures
#   DevState.OFF :    ccd is OFF, ready to take pictures
#   DevState.FAULT :  ccd is in FAULT, cannot take pictures
# ==================================================================


class LimaTacoCCDs(PyTango.LatestDeviceImpl, object):

    core.DEB_CLASS(core.DebModule.DebModApplication, "LimaTacoCCDs")

    # --------- Add you global variables here --------------------------
    LiveDisplay = 1
    FrameAccum = 2
    StripeConcat = 4
    AutoSave = 8
    AutoHeader = 16

    LiveNbConcatFrames = 16

    ImageType2DataArrayType = {
        core.ImageType.Bpp8: 0,
        core.ImageType.Bpp10: 1,
        core.ImageType.Bpp12: 1,
        core.ImageType.Bpp14: 1,
        core.ImageType.Bpp16: 1,
        core.ImageType.Bpp32: 2,
        core.ImageType.Bpp8S: 4,
        core.ImageType.Bpp10S: 5,
        core.ImageType.Bpp12S: 5,
        core.ImageType.Bpp14S: 5,
        core.ImageType.Bpp16S: 5,
        core.ImageType.Bpp32S: 6,
    }

    # --------- TACO specific cmd_list & proxy -------------------------
    TacoSpecificDict = {}
    TacoSpecificName = []

    TacoCmdList = []
    TacoProxy = None
    TacoProxySearched = False

    # --------- Auto-reset Control Status on Error ---------------------
    AutoResetCtStatus = False

    # --------- Method proxy control -----------------------------------
    def __getattribute__(self, name):
        proxy = LimaTacoCCDs.TacoProxy
        if not proxy:
            if LimaTacoCCDs.TacoProxySearched:
                return object.__getattribute__(self, name)

            name_cont = LimaTacoCCDs.TacoSpecificName
            if name_cont:
                taco_dict = LimaTacoCCDs.TacoSpecificDict
                if name_cont[0] in taco_dict:
                    cmd_list, proxy_cont = taco_dict[name_cont[0]]
                    LimaTacoCCDs.TacoCmdList = cmd_list.keys()
                    LimaTacoCCDs.TacoProxy = proxy = proxy_cont[0]
                    try:
                        auto_reset = proxy.getAutoResetCtStatus()
                        LimaTacoCCDs.AutoResetCtStatus = auto_reset
                    except:
                        pass
                TacoProxySearched = True

        if proxy and name in LimaTacoCCDs.TacoCmdList:
            return getattr(proxy, name)
        else:
            return object.__getattribute__(self, name)

    # ------------------------------------------------------------------
    #    Device constructor
    # ------------------------------------------------------------------
    def __init__(self, cl, name):
        PyTango.LatestDeviceImpl.__init__(self, cl, name)
        self.init_device()
        try:
            self.__bpm_mgr = core.Processlib.Tasks.BpmManager()
            self.__bpm_task = core.Processlib.Tasks.BpmTask(self.__bpm_mgr)
        except AttributeError:
            self.__bpm_mgr = None
            self.__bpm_task = None
        self.__key_header_delimiter = "="
        self.__entry_header_delimiter = "\n"
        self.__image_number_header_delimiter = ";"

        self.__last_exp_time = None
        self.__mult_trig_data = None

    # ------------------------------------------------------------------
    #    Device destructor
    # ------------------------------------------------------------------
    def delete_device(self):
        pass

    # ------------------------------------------------------------------
    #    Device initialization
    # ------------------------------------------------------------------
    def init_device(self):
        self.set_state(PyTango.DevState.ON)
        self.get_device_properties(self.get_device_class())
        try:
            self.ManualAsynchronousWrite = int(self.ManualAsynchronousWrite)
        except:
            self.ManualAsynchronousWrite = 0

        # ImageType Bpp32F (Float 32)
        try:
            self.ImageType2DataArrayType[core.ImageType.Bpp32F] = 8
        except AttributeError:
            pass

    # ==================================================================
    #
    #    LimaTacoCCDs read/write attribute methods
    #
    # ==================================================================
    # ------------------------------------------------------------------
    #    Read Attribute Hardware
    # ------------------------------------------------------------------
    def read_attr_hardware(self, data):
        pass

    # ==================================================================
    #
    #    LimaTacoCCDs command methods
    #
    # ==================================================================

    # ------------------------------------------------------------------
    #    TacoState command:
    #
    #    Description:
    #    argout: DevLong taco state
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def TacoState(self):
        state = self.State()
        if state == PyTango.DevState.OFF:
            taco_state = DevCcdReady
        elif state == PyTango.DevState.ON:
            taco_state = DevCcdAcquiring
        else:
            control = _control_ref()
            ct_status = control.getStatus()
            msg = "Acquisition error: %s" % ct_status
            end = msg.index(", ImageCounters")
            msg = msg[:end] + ">"
            if self.AutoResetCtStatus:
                control.resetStatus(True)
            raise core.Exception(msg)
        deb.Return("TACO state: 0x%08x (%d)" % (taco_state, taco_state))
        return taco_state

    # ------------------------------------------------------------------
    #    State command:
    #
    #    Description:
    #    argout: DevLong taco state
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def State(self):
        control = _control_ref()
        ct_status = control.getStatus()
        acq_status = ct_status.AcquisitionStatus
        if acq_status == core.AcqStatus.AcqReady:
            return PyTango.DevState.OFF
        elif acq_status != core.AcqStatus.AcqRunning:
            return PyTango.DevState.FAULT
        elif self.__mult_trig_data is None:
            return PyTango.DevState.ON

        data = self.__mult_trig_data
        if data["state"] == "Ready":
            return PyTango.DevState.OFF
        next_frame = data["last_frame"] + 1
        if next_frame == data["nb_frames"] - 1:
            return PyTango.DevState.ON
        img_counters = ct_status.ImageCounters
        extOp = control.externalOperation()
        link_task_act, sink_task_act = extOp.isTaskActive()
        cnt_attr = "LastCounterReady" if sink_task_act else "LastImageReady"
        last_acq_frame = getattr(img_counters, cnt_attr)
        ready = last_acq_frame == next_frame
        if ready:
            data["state"] = "Ready"
            data["last_frame"] = last_acq_frame
        return PyTango.DevState.OFF if ready else PyTango.DevState.ON

    # ------------------------------------------------------------------
    #    DevCcdStart command:
    #
    #    Description:
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdStart(self):
        control = _control_ref()
        prepare, start = True, True
        data = self.__mult_trig_data
        is_mult_trig = data is not None
        if is_mult_trig:
            acq = control.acquisition()
            ct_status = control.getStatus()
            acq_status = ct_status.AcquisitionStatus
            prepare = acq_status != core.AcqStatus.AcqRunning
            trig_mode = acq.getTriggerMode()
            start = prepare or (trig_mode == core.TrigMode.IntTrigMult)

        if prepare:
            if is_mult_trig:
                acq.setAcqNbFrames(data["nb_frames"])
                data["last_frame"] = -1
            control.prepareAcq()
        if start:
            control.startAcq()
        if is_mult_trig:
            data["state"] = "Running"

    # ------------------------------------------------------------------
    #    DevCcdStop command:
    #
    #    Description:
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdStop(self):
        control = _control_ref()
        control.stopAcq()

    # ------------------------------------------------------------------
    #    DevCcdRead command:
    #
    #    Description:
    #    argin:    DevVarLongArray
    #    argout: DevVarCharArray
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdRead(self, frame_data):
        frame_nb, frame_size = frame_data
        if self.__mult_trig_data is not None and frame_nb == 0:
            frame_nb = self.__mult_trig_data["last_frame"]
        deb.Param("frame_nb=%s, frame_size=%s" % (frame_nb, frame_size))
        control = _control_ref()
        data = control.ReadImage(int(frame_nb))
        self._data_cache = numpy.array(data.buffer.ravel())
        self._data_cache.dtype = numpy.uint8
        release = getattr(data, "releaseBuffer", None)
        if release:
            release()
        if self._data_cache.shape[0] != frame_size:
            raise core.Exception(
                (
                    "Client expects %d bytes, frame has %d"
                    % (frame_size, self._data_cache.shape[0])
                )
            )
        return self._data_cache

    # ------------------------------------------------------------------
    #    DevCcdReadAll command:
    #
    #    Description:
    #    argin:    DevLong
    #    argout: DevEncoded
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdReadAll(self, frame_size):
        deb.Param("frame_size=%s" % frame_size)
        frame_dim = self.__getFrameDim()
        nb_frames = frame_size // frame_dim.getMemSize()
        control = _control_ref()
        image = control.image()
        image_type = image.getImageType()
        da_type = self.ImageType2DataArrayType.get(image_type, "?")
        image_size = frame_dim.getSize()
        da_size = [image_size.getWidth(), image_size.getHeight() * nb_frames]
        da_steps = [frame_dim.getDepth()]
        da_steps += [da_steps[0] * da_size[0]]

        # The DATA_ARRAY definition v2
        # struct {
        # unsigned int Magic= 0x44544159;
        # unsigned short Version;
        # unsigned  short HeaderLength;
        # DataArrayCategory Category;
        # DataArrayType DataType;
        # unsigned short DataEndianness;
        # unsigned short NbDim;
        # unsigned short Dim[6]
        # unsigned int DimStepBytes[6]
        # unsigned int Unused[2]
        # } DataArrayHeaderStruct;

        # enum DataArrayCategory {
        # ScalarStack = 0;
        # Spectrum;
        # Image;
        # SpectrumStack;
        # ImageStack;
        # };

        # enum DataArrayType{
        # DARRAY_UINT8 = 0;
        # DARRAY_UINT16;
        # DARRAY_UINT32;
        # DARRAY_UINT64;
        # DARRAY_INT8;
        # DARRAY_INT16;
        # DARRAY_INT32;
        # DARRAY_INT64;
        # DARRAY_FLOAT32;
        # DARRAY_FLOAT64;
        # };

        # verify (future) backward compatibility
        min_header_len = 64
        header_fmt = "<IHHIIHHHHHHHHIIIIIIII"
        header_len = struct.calcsize(header_fmt)
        if header_len < min_header_len:
            raise RuntimeError(
                "Invalid header len: %d (min. expected %d)"
                % (header_len, min_header_len)
            )

        concat_frames = control.ReadImage(0, nb_frames)
        dtype = concat_frames.buffer.dtype
        big_endian = numpy.dtype(dtype.byteorder + "i4") == numpy.dtype(">i4")

        # prepare the structure
        data_header = struct.pack(
            header_fmt,
            0x44544159,  # 4 bytes I - magic number
            2,  # 2 bytes H - version
            header_len,  # 2 bytes H - this header size
            2,  # 4 bytes I - category (enum)
            da_type,  # 4 bytes I - data type (enum)
            big_endian,  # 2 bytes H - endianness
            2,  # 2 bytes H - nb of dims
            da_size[0],
            da_size[1],
            0,
            0,
            0,
            0,  # 12 bytes H x 6 - dims
            da_steps[0],
            da_steps[1],
            0,
            0,
            0,
            0,  # 24 bytes I x 6 - stepsbytes
            0,
            0,  # padding 2 x 4 bytes
        )
        self._concat_data_cache = data_header + concat_frames.buffer.tostring()
        da_len = len(self._concat_data_cache) - header_len
        release = getattr(concat_frames, "releaseBuffer", None)
        if release:
            release()
        if da_len != frame_size:
            raise core.Exception(
                ("Client expects %d bytes, frame has %d" % (frame_size, da_len))
            )
        return ("DATA_ARRAY", self._concat_data_cache)

    # ------------------------------------------------------------------
    #    DevCcdReadJpeg command:
    #
    #    Description:
    #    argin:    DevShort    jpeg compression
    #    argout: DevVarCharArray jpeg compressed image
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdReadJpeg(self, argin):
        pass

    # ------------------------------------------------------------------
    #    DevCcdWrite command:
    #
    #    Description:
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdWrite(self):
        self.DevCcdWriteFile(-1)

    # ------------------------------------------------------------------
    #    DevCcdSetExposure command:
    #
    #    Description:
    #    argin:    DevFloat
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdSetExposure(self, exp_time):
        deb.Param("Setting exp. time: %s" % exp_time)

        control = _control_ref()
        acq = control.acquisition()

        trig_mode = acq.getTriggerMode()
        if exp_time == 0 and trig_mode == core.TrigMode.ExtTrigSingle:
            acq.setTriggerMode(core.TrigMode.ExtGate)
        elif exp_time > 0 and trig_mode == core.TrigMode.ExtGate:
            acq.setTriggerMode(core.TrigMode.ExtTrigSingle)
        if exp_time > 0.0:
            acq.setAcqExpoTime(exp_time)

        self.__last_exp_time = exp_time

    # ------------------------------------------------------------------
    #    DevCcdGetExposure command:
    #
    #    Description: read ccd exposure
    #
    #    argout: DevFloat
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdGetExposure(self):
        control = _control_ref()
        acq = control.acquisition()
        return acq.getAcqExpoTime()

    # ------------------------------------------------------------------
    #    DevCcdSetRoI command:
    #
    #    Description:
    #    argin:    DevVarLongArray
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdSetRoI(self, argin):
        roi = core.Roi(core.Point(argin[0], argin[1]), core.Point(argin[2], argin[3]))
        control = _control_ref()
        image = control.image()
        if roi == self.getMaxRoi():
            roi = core.Roi()
        image.setRoi(roi)

    # ------------------------------------------------------------------
    #    DevCcdGetRoI command:
    #
    #    Description: get the region of interest coordinates
    #
    #    argout: DevVarLongArray region of interest
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdGetRoI(self):
        control = _control_ref()
        image = control.image()
        roi = image.getRoi()
        if roi.isEmpty():
            roi = self.getMaxRoi()

        tl = roi.getTopLeft()
        br = roi.getBottomRight()
        return [tl.x, tl.y, br.x, br.y]

    @core.DEB_MEMBER_FUNCT
    def getMaxRoi(self):
        control = _control_ref()
        ct_image = control.image()
        max_roi_size = ct_image.getMaxImageSize()
        max_roi_size /= core.Point(ct_image.getBin())
        max_roi = core.Roi(core.Point(0, 0), max_roi_size)
        return max_roi

    # ------------------------------------------------------------------
    #    DevCcdSetFilePar command:
    #
    #    Description:
    #    argin:    DevVarStringArray
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdSetFilePar(self, par_arr):
        deb.Param("Setting file pars: %s" % par_arr)
        control = _control_ref()
        saving = control.saving()
        pars = saving.getParameters()
        pars.directory = par_arr[0]
        pars.prefix = par_arr[1]
        pars.suffix = par_arr[2]
        pars.nextNumber = int(par_arr[3])
        index_format = par_arr[4]

        if par_arr[5] in ["y", "yes"]:
            pars.overwritePolicy = core.CtSaving.OverwritePolicy.Overwrite
        else:
            pars.overwritePolicy = core.CtSaving.OverwritePolicy.Abort
        if pars.suffix.lower()[-4:] == ".edf":
            pars.fileFormat = core.CtSaving.FileFormat.EDF
        elif pars.suffix.lower()[-6:] == ".edfgz":
            pars.fileFormat = core.CtSaving.FileFormat.EDFGZ
        elif pars.suffix.lower()[-7:] == ".edf.gz":
            pars.fileFormat = core.CtSaving.FileFormat.EDFGZ
        elif pars.suffix.lower()[-4:] == ".cbf":
            pars.fileFormat = core.CtSaving.FileFormat.CBFFormat
        elif pars.suffix.lower()[-3:] == ".h5":
            pars.fileFormat = core.CtSaving.FileFormat.HDF5
        elif pars.suffix.lower()[-5:] == ".h5gz":
            pars.fileFormat = core.CtSaving.FileFormat.HDF5GZ
        elif pars.suffix.lower()[-5:] == ".h5bs":
            pars.fileFormat = core.CtSaving.FileFormat.HDF5BS
        elif pars.suffix.lower()[-5:] == ".hdf5":
            pars.fileFormat = core.CtSaving.FileFormat.HDF5
        elif pars.suffix.lower()[-7:] == ".hdf5gz":
            pars.fileFormat = core.CtSaving.FileFormat.HDF5GZ
        elif pars.suffix.lower()[-7:] == ".hdf5bs":
            pars.fileFormat = core.CtSaving.FileFormat.HDF5BS
        elif pars.suffix.lower()[-5:] == ".tiff":
            pars.fileFormat = core.CtSaving.FileFormat.TIFFFormat
        elif pars.suffix.lower()[-8:] == ".edf.lz4":
            pars.fileFormat = core.CtSaving.FileFormat.EDFLZ4
        elif pars.suffix.lower()[-7:] == ".edflz4":
            pars.fileFormat = core.CtSaving.FileFormat.EDFLZ4
        else:
            pars.fileFormat = core.CtSaving.FileFormat.RAW
        saving.setParameters(pars)

    # ------------------------------------------------------------------
    #    DevCcdGetFilePar command:
    #
    #    Description:
    #    argout: DevVarStringArray
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdGetFilePar(self):
        control = _control_ref()
        saving = control.saving()
        pars = saving.getParameters()
        overwrite = pars.overwritePolicy == core.CtSaving.OverwritePolicy.Overwrite
        over_str = "yes" if overwrite else "no"
        index_format = "%04d"
        arr = [
            pars.directory,
            pars.prefix,
            pars.suffix,
            pars.nextNumber,
            index_format,
            over_str,
        ]
        par_arr = [str(s) for s in arr]
        deb.Return("File pars: %s" % par_arr)
        return par_arr

    # ------------------------------------------------------------------
    #    DevCcdHeader command:
    #
    #    Description:
    #    argout: DevVarStringArray
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdHeader(self, header_str):
        deb.Param("Setting file header: %s" % header_str)
        control = _control_ref()
        saving = control.saving()
        header_map = {}
        for line in header_str.split(self.__entry_header_delimiter):
            token = line.split(self.__key_header_delimiter)
            key = token[0].strip()
            if not key:
                continue
            try:
                val = "=".join(token[1:]).strip()
            except ValueError:
                continue
            if val.endswith(";"):
                val = val[:-1]
            header_map[key] = val
        savingMode = saving.getSavingMode()
        if savingMode != core.CtSaving.SavingMode.AutoHeader:
            saving.setCommonHeader(header_map)
        else:
            imageStatus = control.getImageStatus()
            NextImageSaved = imageStatus.LastImageSaved + 1
            saving.updateFrameHeader(NextImageSaved, header_map)

    # ------------------------------------------------------------------
    #    DevCcdImageHeader command:
    #
    #    Description:
    #    argout: DevVarStringArray
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdImageHeader(self, headers_str):
        control = _control_ref()
        saving = control.saving()
        for image_header in headers_str:
            imageIdSepPos = image_header.find(self.__image_number_header_delimiter)
            imageId = int(image_header[:imageIdSepPos])
            header_str = image_header[imageIdSepPos + 1 :]
            deb.Param("Setting to image %d file header: %s" % (imageId, header_str))
            header_map = {}
            for line in header_str.split(self.__entry_header_delimiter):
                token = line.split(self.__key_header_delimiter)
                key = token[0].strip()
                if not key:
                    continue
                try:
                    val = "=".join(token[1:]).strip()
                except ValueError:
                    continue
                if val.endswith(";"):
                    val = val[:-1]
                header_map[key] = val
            saving.updateFrameHeader(imageId, header_map)

    @core.DEB_MEMBER_FUNCT
    def DevCcdHeaderDelimiter(self, delimiter):
        deb.Param("Setting file header delimiter: %s" % delimiter)
        self.__key_header_delimiter = delimiter[0]
        self.__entry_header_delimiter = delimiter[1]
        if len(delimiter) > 2:
            self.__image_number_header_delimiter = delimiter[2]

    # ------------------------------------------------------------------
    #    DevCcdDepth command:
    #
    #    Description: read depth of image in bits
    #
    #    argout: DevLong
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdDepth(self):
        control = _control_ref()
        image = control.image()
        image_type = image.getImageType()
        return core.FrameDim.getImageTypeDepth(image_type)

    # ------------------------------------------------------------------
    #    DevCcdYSize command:
    #
    #    Description: get ccd y dimension in pixels
    #
    #    argout: DevLong
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdYSize(self):
        frame_dim = self.__getFrameDim(max_dim=True)
        size = frame_dim.getSize()
        return size.getHeight()

    # ------------------------------------------------------------------
    #    DevCcdXSize command:
    #
    #    Description: get ccd image x dimension in pixels
    #
    #    argout: DevLong
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdXSize(self):
        frame_dim = self.__getFrameDim(max_dim=True)
        size = frame_dim.getSize()
        return size.getWidth()

    # ------------------------------------------------------------------
    #    DevCcdReset command:
    #
    #    Description: reset ccd
    #
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdReset(self):
        control = _control_ref()
        control.reset()

    # ------------------------------------------------------------------
    #    DevCcdSetMode command:
    #
    #    Description:
    #    argin:    DevLong mode
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdSetMode(self, mode):
        deb.Param("Setting mode: %s (0x%x)" % (mode, mode))
        stripe_concat = mode & self.StripeConcat
        frame_accum = mode & self.FrameAccum
        self.setAcqMode(stripe_concat, frame_accum)
        live_display = (mode & self.LiveDisplay) != 0
        if live_display:
            deb.Warning(
                "Warning: SPS live display is no longer supported "
                "and will be ignored"
            )
        auto_save = (mode & self.AutoSave) != 0
        auto_header = (mode & self.AutoHeader) != 0
        self.setAutosave(auto_save, auto_header)

    # ------------------------------------------------------------------
    #    DevCcdGetMode command:
    #
    #    Description:
    #    argout: DevLong
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdGetMode(self):
        mode = 0
        stripe_concat, frame_accum = self.getAcqMode()
        if stripe_concat:
            mode |= self.StripeConcat
        if frame_accum:
            mode |= self.FrameAccum
        autosave_act, auto_header = self.getAutosave()
        if autosave_act:
            mode |= self.AutoSave
        if auto_header:
            mode |= self.AutoHeader
        deb.Return("Getting mode: %s (0x%x)" % (mode, mode))
        return mode

    @core.DEB_MEMBER_FUNCT
    def setAutosave(self, autosave_act, auto_header):
        control = _control_ref()
        saving = control.saving()
        deb.Param("Setting autosave active: %s" % autosave_act)
        if autosave_act:
            saving_mode = (
                auto_header
                and core.CtSaving.SavingMode.AutoHeader
                or core.CtSaving.SavingMode.AutoFrame
            )
        else:
            saving_mode = core.CtSaving.SavingMode.Manual
        saving.setSavingMode(saving_mode)

    @core.DEB_MEMBER_FUNCT
    def getAutosave(self):
        control = _control_ref()
        saving = control.saving()
        saving_mode = saving.getSavingMode()
        auto_header = saving_mode == core.CtSaving.SavingMode.AutoHeader
        autosave_act = auto_header or (
            saving_mode == core.CtSaving.SavingMode.AutoFrame
        )
        deb.Return("Getting autosave active: %s" % autosave_act)
        return autosave_act, auto_header

    @core.DEB_MEMBER_FUNCT
    def setAcqMode(self, stripe_concat, frame_accum):
        deb.Param(
            "Setting acq. mode: stripe_concat=%s, frame_accum=%s"
            % (stripe_concat, frame_accum)
        )
        if not stripe_concat and not frame_accum:
            acq_mode = core.AcqMode.Single
        elif stripe_concat and not frame_accum:
            acq_mode = core.AcqMode.Concatenation
        elif not stripe_concat and frame_accum:
            acq_mode = core.AcqMode.Accumulation
        else:
            err_msg = "Invalid acq. mode: stripe_concat=%s, frame_accum=%s" % (
                stripe_concat,
                frame_accum,
            )
            raise core.Exception(err_msg)
        control = _control_ref()
        acq = control.acquisition()
        acq.setAcqMode(acq_mode)

    @core.DEB_MEMBER_FUNCT
    def getAcqMode(self):
        control = _control_ref()
        acq = control.acquisition()
        acq_mode = acq.getAcqMode()
        stripe_concat = acq_mode == core.AcqMode.Concatenation
        frame_accum = acq_mode == core.AcqMode.Accumulation
        deb.Return(
            "Getting acq. mode: stripe_concat=%s, frame_accum=%s"
            % (stripe_concat, frame_accum)
        )
        return stripe_concat, frame_accum

    # ------------------------------------------------------------------
    #    DevCcdWriteFile command:
    #
    #    Description:
    #    argin:    DevLong frame to write
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdWriteFile(self, frame_nb):
        if self.__mult_trig_data is not None and frame_nb == 0:
            frame_nb = self.__mult_trig_data["last_frame"]
        synchronous = not self.ManualAsynchronousWrite
        control = _control_ref()
        saving = control.saving()
        try:
            saving.writeFrame(frame_nb, 1, synchronous)
        except TypeError:
            saving.writeFrame(frame_nb, 1)

    # ------------------------------------------------------------------
    #    DevCcdWriteAll command:
    #
    #    Description:
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdWriteAll(self):
        control = _control_ref()
        acq = control.acquisition()
        nbConcat = acq.getConcatNbFrames()

        saving = control.saving()
        saving.writeFrame(0, nbConcat)

    # ------------------------------------------------------------------
    #    DevCcdGetBin command:
    #
    #    Description:
    #    argout: DevVarLongArray
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdGetBin(self):
        control = _control_ref()
        image = control.image()
        bin = image.getBin()
        return [bin.getX(), bin.getY()]

    # ------------------------------------------------------------------
    #    DevCcdSetBin command:
    #
    #    Description:
    #    argin:    DevVarLongArray
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdSetBin(self, argin):
        bin = core.Bin(argin[1], argin[0])
        control = _control_ref()
        image = control.image()
        image.setBin(bin)

    # ------------------------------------------------------------------
    #    DevCcdSetFrames command:
    #
    #    Description:
    #    argin:    DevLong
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdSetFrames(self, nb_frames):
        is_mult_trig = self.__mult_trig_data is not None
        if is_mult_trig and (nb_frames == 1):
            return

        control = _control_ref()
        acquisition = control.acquisition()
        acquisition.setAcqNbFrames(nb_frames)
        stripe_concat, frame_accum = self.getAcqMode()
        if stripe_concat:
            nb_concat_frames = nb_frames or self.LiveNbConcatFrames
            acquisition.setConcatNbFrames(nb_concat_frames)

    # ------------------------------------------------------------------
    #    DevCcdGetFrames command:
    #
    #    Description:
    #    argout: DevLong
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdGetFrames(self):
        control = _control_ref()
        acquisition = control.acquisition()
        return acquisition.getAcqNbFrames()

    # ------------------------------------------------------------------
    #    DevCcdSetTrigger command:
    #
    #    Description:
    #    argin:    DevLong
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdSetTrigger(self, argin):
        control = _control_ref()
        acquisition = control.acquisition()

        triggerMode = None
        if argin == 0:
            triggerMode = core.TrigMode.IntTrig
        elif argin == 1:
            triggerMode = core.TrigMode.ExtTrigSingle
            if self.__last_exp_time is not None:
                if self.__last_exp_time == 0:
                    triggerMode = core.TrigMode.ExtGate
        elif argin == 2:
            triggerMode = core.TrigMode.ExtTrigMult
        elif argin == 3:
            triggerMode = core.TrigMode.ExtStartStop
        elif argin == 4:
            triggerMode = core.TrigMode.ExtTrigReadout
        else:
            raise core.Exception("Invalid ext. trig: %s" % argin)

        acquisition.setTriggerMode(triggerMode)

    # ------------------------------------------------------------------
    #    DevCcdGetTrigger command:
    #
    #    Description:
    #    argin:    DevLong
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdGetTrigger(self):
        control = _control_ref()
        acquisition = control.acquisition()
        triggerMode = acquisition.getTriggerMode()
        if (
            triggerMode == core.TrigMode.IntTrig
            or triggerMode == core.TrigMode.IntTrigMult
        ):
            returnValue = 0
        elif (
            triggerMode == core.TrigMode.ExtTrigSingle
            or triggerMode == core.TrigMode.ExtGate
        ):
            returnValue = 1
        elif triggerMode == core.TrigMode.ExtTrigMult:
            returnValue = 2
        elif triggerMode == core.TrigMode.ExtStartStop:
            returnValue = 3
        elif triggerMode == core.TrigMode.ExtTrigReadout:
            returnValue = 4
        else:
            raise core.Exception("Invalid trigger mode: %s" % triggerMode)
        return returnValue

    # ------------------------------------------------------------------
    #    DevReadValues command:
    #
    #    Description:
    #    argout: DevVarDoubleArray
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevReadValues(self):
        control = _control_ref()
        img_data = control.ReadImage(-1)
        self.__bpm_task.process(img_data)
        release = getattr(img_data, "releaseBuffer", None)
        if release:
            release()
        bpm_pars = self.__bpm_mgr.getResult(1)
        if bpm_pars.errorCode != self.__bpm_mgr.OK:
            raise core.Exception(
                "Error calculating beam params: %d" % bpm_pars.errorCode
            )

        nr_spots = 1
        auto_cal = -1
        exp_time = self.DevCcdGetExposure()
        if exp_time > 0:
            norm_intensity = bpm_pars.beam_intensity / exp_time
        else:
            norm_intensity = 0
        return [
            nr_spots,
            bpm_pars.beam_intensity,
            bpm_pars.beam_center_x,
            bpm_pars.beam_center_y,
            bpm_pars.beam_fwhm_x,
            bpm_pars.beam_fwhm_y,
            bpm_pars.AOI_max_x - bpm_pars.AOI_min_x,
            bpm_pars.AOI_max_y - bpm_pars.AOI_min_y,
            bpm_pars.max_pixel_value,
            bpm_pars.max_pixel_x,
            bpm_pars.max_pixel_y,
            bpm_pars.AOI_min_x,
            bpm_pars.AOI_min_y,
            bpm_pars.AOI_max_x,
            bpm_pars.AOI_max_y,
            bpm_pars.beam_center_x - bpm_pars.beam_fwhm_x / 2,
            bpm_pars.beam_center_y - bpm_pars.beam_fwhm_y / 2,
            bpm_pars.beam_center_x + bpm_pars.beam_fwhm_x / 2,
            bpm_pars.beam_center_y + bpm_pars.beam_fwhm_y / 2,
            norm_intensity,
            auto_cal,
        ]

    # ------------------------------------------------------------------
    #    DevReadSigValues command:
    #
    #    Description:
    #    argout: DevVarDoubleArray
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevReadSigValues(self):
        exp_time = self.DevCcdGetExposure()
        threshold = 0
        calib_intensity = -1
        control = _control_ref()
        image = control.image()
        max_dim = image.getMaxImageSize()
        roi = self.DevCcdGetRoI()
        is_live = -1
        ccd_params = [
            exp_time,
            threshold,
            calib_intensity,
            max_dim.getWidth(),
            max_dim.getHeight(),
            roi[0],
            roi[1],
            roi[2],
            roi[3],
            is_live,
        ]
        ccd_params += self.DevReadValues()
        return ccd_params

    # ------------------------------------------------------------------
    #    DevCcdGetLstErrMsg command:
    #
    #    Description: Get the last error message is mapped to the status of the Tango ccd device
    #
    #    argout: DevString
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdGetLstErrMsg(self):
        return ""  # not managed yet!

    # ------------------------------------------------------------------
    #    DevCcdGetCurrent command:
    #
    #    Description: Get the current acquired frame number
    #    argout: DevLong
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdGetCurrent(self):
        control = _control_ref()
        ct_status = control.getStatus()
        saving = control.saving()
        img_counters = ct_status.ImageCounters
        saving_act = saving.getSavingMode() == core.CtSaving.SavingMode.AutoFrame
        cnt_attr = "LastImageSaved" if saving_act else "LastImageAcquired"
        data = self.__mult_trig_data
        if data is not None:
            extOp = control.externalOperation()
            link_task_act, sink_task_act = extOp.isTaskActive()
            last_frame = data["nb_frames"] - 1
            next_frame = data["last_frame"] + 1
            is_last_exp = (data["state"] == "Running") and (next_frame == last_frame)
            if sink_task_act and not is_last_exp:
                cnt_attr = "LastCounterReady"
        last_frame_nb = getattr(img_counters, cnt_attr)
        nb_frames = last_frame_nb + 1
        deb.Return("Nb of frames: %s" % nb_frames)
        return nb_frames

    # ------------------------------------------------------------------
    #    DevSetDebugFlags command:
    #
    #    Description: Get the current acquired frame number
    #    argin: DevULong
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevSetDebugFlags(self, deb_flags):
        deb_flags &= 0xFFFFFFFF
        deb.Param("Setting debug flags: 0x%08x" % deb_flags)
        core.DebParams.setTypeFlags((deb_flags >> 16) & 0xFF)
        core.DebParams.setModuleFlags((deb_flags >> 0) & 0xFFFF)

        deb.Trace("FormatFlags: %s" % core.DebParams.getFormatFlagsNameList())
        deb.Trace("TypeFlags:   %s" % core.DebParams.getTypeFlagsNameList())
        deb.Trace("ModuleFlags: %s" % core.DebParams.getModuleFlagsNameList())

    # ------------------------------------------------------------------
    #    DevGetDebugFlags command:
    #
    #    Description: Get the current acquired frame number
    #    argout: DevULong
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevGetDebugFlags(self):
        deb.Trace("FormatFlags: %s" % core.DebParams.getFormatFlagsNameList())
        deb.Trace("TypeFlags:   %s" % core.DebParams.getTypeFlagsNameList())
        deb.Trace("ModuleFlags: %s" % core.DebParams.getModuleFlagsNameList())

        deb_flags = ((core.DebParams.getTypeFlags() & 0xFF) << 16) | (
            (core.DebParams.getModuleFlags() & 0xFFFF) << 0
        )
        deb_flags &= 0xFFFFFFFF
        deb.Return("Getting debug flags: 0x%08x" % deb_flags)
        return deb_flags

    # ------------------------------------------------------------------
    #    DevCcdSetMultTrigNbFrames command:
    #
    #    Description: Set the current nb. of frames in mult-trig mode
    #    argin: DevULong
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdSetMultTrigNbFrames(self, nb_frames):
        deb.Param("Setting mult-trig nb_frames: %d" % nb_frames)
        if nb_frames < 1:
            raise core.Exception("Invalid nb_frames=%d" % nb_frames)
        self.__mult_trig_data = dict(nb_frames=nb_frames, state="Ready", last_frame=-1)

    # ------------------------------------------------------------------
    #    DevCcdGetMultTrigNbFrames command:
    #
    #    Description: Get the current acquired frame number
    #    argout: DevULong
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdGetMultTrigNbFrames(self):
        data = self.__mult_trig_data
        nb_frames = data["nb_frames"] if data is not None else 0
        deb.Return("Getting mult-trig nb_frames: %d" % nb_frames)
        return nb_frames

    # ------------------------------------------------------------------
    #    DevCcdResetMultTrigNbFrames command:
    #
    #    Description: Reset the mult-trig mode - go to standard
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def DevCcdResetMultTrigNbFrames(self):
        deb.Param("Resetting mult-trig nb_frames")
        if self.__mult_trig_data is None:
            return
        control = _control_ref()
        acq = control.acquisition()
        acq.setAcqNbFrames(1)
        self.__mult_trig_data = None

    # ------------------------------------------------------------------
    #    DevGetCurrent command:
    #
    #    Description: Get the current acquired frame number
    #    argout: DevVarDoubleArray
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def __getFrameDim(self, max_dim=False):
        control = _control_ref()
        image = control.image()
        if max_dim:
            size = image.getMaxImageSize()
            frame_dim = core.FrameDim(size, image.getImageType())
        else:
            frame_dim = image.getImageDim()
        return frame_dim

    # ------------------------------------------------------------------
    #   dummy method
    # ------------------------------------------------------------------
    @core.DEB_MEMBER_FUNCT
    def dummy(self, *args):
        raise core.Exception("Taco command not supported for this camera")


# ==================================================================
#
#    LimaTacoCCDsClass class definition
#
# ==================================================================
class LimaTacoCCDsClass(PyTango.DeviceClass):

    #    Class Properties
    class_property_list = {}

    #    Device Properties
    device_property_list = {
        "ManualAsynchronousWrite": [PyTango.DevString, "Flag for manual writting", [0]]
    }

    #    Command definitions
    cmd_list = {
        "TacoState": [[PyTango.DevVoid, ""], [PyTango.DevLong, "taco state"]],
        "DevCcdStart": [[PyTango.DevVoid, ""], [PyTango.DevVoid, ""]],
        "DevCcdStop": [[PyTango.DevVoid, ""], [PyTango.DevVoid, ""]],
        "DevCcdRead": [
            [PyTango.DevVarLongArray, "frame_nb, frame_size"],
            [PyTango.DevVarCharArray, "raw image"],
        ],
        "DevCcdReadAll": [
            [PyTango.DevLong, "frame_size"],
            [PyTango.DevEncoded, "concatenated image"],
        ],
        "DevCcdReadJpeg": [
            [PyTango.DevShort, "jpeg compression"],
            [PyTango.DevVarCharArray, "jpeg compressed image"],
        ],
        "DevCcdWrite": [[PyTango.DevVoid, ""], [PyTango.DevVoid, ""]],
        "DevCcdSetExposure": [[PyTango.DevFloat, ""], [PyTango.DevVoid, ""]],
        "DevCcdGetExposure": [[PyTango.DevVoid, ""], [PyTango.DevFloat, ""]],
        "DevCcdSetRoI": [[PyTango.DevVarLongArray, ""], [PyTango.DevVoid, ""]],
        "DevCcdSetFilePar": [[PyTango.DevVarStringArray, ""], [PyTango.DevVoid, ""]],
        "DevCcdHeader": [[PyTango.DevString, ""], [PyTango.DevVoid, ""]],
        "DevCcdImageHeader": [[PyTango.DevVarStringArray, ""], [PyTango.DevVoid, ""]],
        "DevCcdHeaderDelimiter": [
            [PyTango.DevVarStringArray, ""],
            [PyTango.DevVoid, ""],
        ],
        "DevCcdGetFilePar": [[PyTango.DevVoid, ""], [PyTango.DevVarStringArray, ""]],
        "DevCcdDepth": [[PyTango.DevVoid, ""], [PyTango.DevLong, ""]],
        "DevCcdYSize": [[PyTango.DevVoid, ""], [PyTango.DevLong, ""]],
        "DevCcdXSize": [[PyTango.DevVoid, ""], [PyTango.DevLong, ""]],
        "DevCcdReset": [[PyTango.DevVoid, ""], [PyTango.DevVoid, ""]],
        "DevCcdSetMode": [[PyTango.DevLong, "mode"], [PyTango.DevVoid, ""]],
        "DevCcdGetMode": [[PyTango.DevVoid, ""], [PyTango.DevLong, ""]],
        "DevCcdWriteFile": [[PyTango.DevLong, "frame to write"], [PyTango.DevVoid, ""]],
        "DevCcdWriteAll": [[PyTango.DevVoid, ""], [PyTango.DevVoid, ""]],
        "DevCcdGetBin": [[PyTango.DevVoid, ""], [PyTango.DevVarLongArray, ""]],
        "DevCcdSetBin": [[PyTango.DevVarLongArray, ""], [PyTango.DevVoid, ""]],
        "DevCcdSetFrames": [[PyTango.DevLong, ""], [PyTango.DevVoid, ""]],
        "DevCcdGetFrames": [[PyTango.DevVoid, ""], [PyTango.DevLong, ""]],
        "DevCcdSetTrigger": [[PyTango.DevLong, ""], [PyTango.DevVoid, ""]],
        "DevCcdGetTrigger": [[PyTango.DevVoid, ""], [PyTango.DevLong, ""]],
        "DevCcdGetRoI": [
            [PyTango.DevVoid, ""],
            [PyTango.DevVarLongArray, "region of interest"],
        ],
        "DevReadValues": [[PyTango.DevVoid, ""], [PyTango.DevVarDoubleArray, ""]],
        "DevReadSigValues": [[PyTango.DevVoid, ""], [PyTango.DevVarDoubleArray, ""]],
        "DevCcdGetLstErrMsg": [[PyTango.DevVoid, ""], [PyTango.DevString, ""]],
        "DevCcdGetCurrent": [[PyTango.DevVoid, ""], [PyTango.DevLong, ""]],
        "DevCcdGetMultTrigNbFrames": [[PyTango.DevVoid, ""], [PyTango.DevULong, ""]],
        "DevCcdSetMultTrigNbFrames": [[PyTango.DevULong, ""], [PyTango.DevVoid, ""]],
        "DevCcdResetMultTrigNbFrames": [[PyTango.DevVoid, ""], [PyTango.DevVoid, ""]],
        "DevGetDebugFlags": [[PyTango.DevVoid, ""], [PyTango.DevULong, ""]],
        "DevSetDebugFlags": [[PyTango.DevULong, ""], [PyTango.DevVoid, ""]],
    }

    #    Attribute definitions
    attr_list = {}

    # ------------------------------------------------------------------
    #    LimaTacoCCDsClass Constructor
    # ------------------------------------------------------------------
    def __init__(self, name):
        PyTango.DeviceClass.__init__(self, name)
        self.set_type(name)


_control_ref = None


def set_control_ref(ctrl):
    global _control_ref
    _control_ref = ctrl


def get_tango_specific_class_n_device():
    return LimaTacoCCDsClass, LimaTacoCCDs


def set_taco_specific_dict_n_name_cont(taco_dict, name_cont):
    LimaTacoCCDs.TacoSpecificDict = taco_dict
    LimaTacoCCDs.TacoSpecificName = name_cont
    for cmd_list, proxy_cont in taco_dict.values():
        LimaTacoCCDsClass.cmd_list.update(cmd_list)
        proxy_class = proxy_cont[0].__class__
        for cmd in cmd_list.keys():
            try:
                getattr(LimaTacoCCDs, cmd)
            except:
                setattr(LimaTacoCCDs, cmd, LimaTacoCCDs.dummy)
